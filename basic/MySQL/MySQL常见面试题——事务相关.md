# MySQL常见面试题——索引相关

## ACID是什么

ACID这个词汇经常听一些老程序员提，最开始的时候感觉很高端，然后去查了一下，发现其实就是**事务的四个性质/标准**，这个东西不光在MySQL中存在，而是普适于所有的事务机制的

- **Atomicity/原子性**：一个事务的操作要么全部完成，要么全部寄掉
- **Consistency/一致性**：事务操作的对象之间数据保持一致
- **Isolation/隔离性**：允许并发操作（其实是说同时执行多个事务互不影响）
- **Duration/持久性**： 事务结束后数据的修改要持久，不能说一会之后又因为某些奇奇怪怪的故障变回去了，也可以说是数据要持久化

## 脏读/幻读/不可重复读？

这三个都是关于并发相关的问题，只有在`并发环境`下`处理多个事务之间`会出现的问题

首先我们得理解一个事——这三个问题其实都是由于`时间与状态之间的矛盾`而导致的

我们认为/规定一个事务应该是`在一个时间点的状态下`完成的，但是由于事务包含多个操作，这些操作自然不可能同时完成，同是由于ACID还要求事务应该支持并发，这就导致了A事务的某个操作可能还在进行的过程中B事务就对表中A事务使用的数据进行了修改，这时由于我们希望事务的操作是`在一个时间点的状态下`完成的，这就发生了矛盾
### 脏读

> A事务读到了B事务正在修改过了但尚未提交的数据

由于一个事务在提交前有可能发生回滚操作，这时A事务使用B事务尚未提交但已经修改了的数据，B事务再将数据回滚，直接烂完

## 幻读

> 一个事务内按照某个条件**查询对应条件的数据的数量/列数**，结果查询的数据前后不一致

A事务查询的过程中B事务可能进行新增操作并完成提交，这时A事务再次查询就会出现与上一次查询不同的数据量
### 不可重复读

> 一个事务内对一条数据进行多次查询，前后数据不一致

A事务查询的过程中B事务可能对A事务查询的数据进行修改操作并完成提交，这时A事务再次查询就会出现与上一次查询不同的数据

## MySQL如何解决上面的这些问题？

- **锁**：MySQL使用了多种锁来保证一致性
- **事务隔离机制**：MySQL通过多种事务隔离机制来控制各个事务之间的隔离层度
- **多版本并发控制/MVCC**：通过在数据库中保存不同版本的数据来实现不同事务的隔离，在读操作时会选取合适的版本来进行读取

## MySQL的隔离等级

所谓的隔离等级其实就是对事务的隔离层度进行的分级，按隔离程度的高低由低到高会区分为：

- **读未提交**：指一个事务在还没提交的时候，他做的变更可以被其他的事务看到（也就是基本不隔离）
- **读提交**：指事务提交后变更才可以被看到（也就是最符合逻辑的隔离方式）
- **可重复读**：指一个事务执行过程中看到的数据与这事务启动的时候看到的一致，这也是InnoDB种默认的隔离机制。这里需要注意的是，可重复读生成的快照通常针对的是事务开始时已经存在的数据行，以及这些数据行的历史版本，并不针对（这种状态已经不顾及其他事务的隔离等级，要求事务执行中看到的数据始终是一个时刻的）
- **串行化**：对一条记录上锁，若多个事务对该记录进行读写操作，如果发生读写冲突，则阻塞进行