# JVM虚拟机：内存——Java的尝试

Java为了省去c/c++繁琐的申请/删除的操作，决定将这一系列控制权交给JVM托管，程序员更关注业务的实现，而一些和业务无关且繁琐的内存操作就有JVM托管了

## Java的数据区域

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

接下来我们会一一讲述这些东西

## 程序计数器

程序计数器是用来处理线程字节码的一块区域，每个线程都都有一个。

* 字节码通过改变程序计数器来读取指令，进而实现代码的流程控制
* 程序计数器还记录了当前线程运行的位置，进而在多线程情景下，时间轮转的过程仍然可以记住线程上次运行的位置

**程序计数器是唯一一个不会出现 OutOfMemoryError的内存区域**

## Java虚拟机栈

相信栈这个东西大家都不陌生，C语言中也有栈这个东西，而我们的Java虚拟机栈与之类似。

当方法调用时，我们会向栈中压入一个栈帧，方法调用结束时会弹出栈帧。

每个栈帧中又包含了**局部变量表，操作数栈，动态链路和方法返回地址**

* **局部变量表：**存储方法的参数和方法内部定义的局部变量。（创造或外界传入时存放在此处）

* **操作数栈：** 临时保存运算/变量被使用过程中使用的数据（如数值、引用、计算结果等，这些数据可能出现在局部变量表中）

* **动态链路：**

  服务于一个方法需要调用其他方法的场景。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为**动态连接** 。

  **符号引用：**编译后的字节码，类，方法，字段使用的都不是内存中的直接引用，而是使用了一种间接的引用方式，我们称之为符号引用

  **直接引用**：引用内存上的地址

  符号引用转换直接引用支持了多态

  ```java
  Animal dog=new Dog();
  ```

  在上例中，我们的Dog是Animal的一个实现类，在编译器，我们会将dog变量认为是Animal类型的变量，这就是符号引用， 而在运行期，通过动态链路将符号引用转换为调用方法的直接引用的这一过程，我们才可以将dog变量视为Dog类，进而使用Dog类中定义的方法实现。

当中被压入太多栈帧而占用太多空间时，会抛出StackOverFlowError异常

## 本地方法栈

类似虚拟机栈，但是使用来运行本地方法的（native方法）

## 堆

Java虚拟机各线程的共享内存区域，这一块主要是存放对象实例，几乎所有的对象实例都在这里创建。

在JDK1.7时Java默认开启了逃逸分析，如果某些对象的引用未被返回或未被外界外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

堆是垃圾收集器的主要管理区域，因此也被称为GC堆（Garbage Collection Heap），由于现代的收集器基本都采用分代垃圾收集算法，因此可以细分为：新生代和老年代。

堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. Metaspace(元空间，1.8及以后版本) / 永久代(Permanent Generation，1.7及以前版本使用)







