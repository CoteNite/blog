# Java内存机制


如果想要理解JVM，那么我们就要知道JVM存在的意义是什么。

在C语言中，如果我们主动的去申请了一段空间，如何申请，申请后那么就需要后续通过free的方式去将其释放掉。我相信大多数熟练的工程师应该不会忘掉free的这一步骤，但是这一步骤实在显得有些麻烦，且何时free也是一个问题。

为了简化工程师的思考，方便程序员进行编程，Java决定将这一过程交给JVM去处理，而本文则是去试图阐述这一过程。

## 存储

我们都知道，数据在我们是存储在我们的电脑内存中的，那么究竟是如何存储的呢？

首先，根据线程的关系，我们可以将其分为 **线程私有和线程共有** 这两部分。

其中

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

接下来我们试着依次去解释这些东西。

## 程序计数器

我们都知道，在并发环境下，多个线程是依次执行的，在线程切换的过程中，我们需要找一个区域去存放我们的程序现在执行到了何处/下一行代码该执行哪个，这就是程序计数器要完成的任务。

由于控制着下一条命令的选取，因此字节码解释器只需要对程序计数器进行修改就可以完成循环，判断等复杂操作。

**由于记录的是当前程序要执行的下一条，因此程序计数器是线程私有的。**

**由于程序计数器维护的是一个动态变化的东西（即下一条指令是什么/只是记录一个固定量的东西），且会随着线程的结束而消亡，因此不会OOM**

## Java虚拟机栈

刚刚提到程序计数器是用来维护“下一条”指令来完成指令的选取，只有程序计数器显然是远远不够的（很明显，程序计数器更加“瞬时”一点），我们还需要一个稍微相对程序计数器宏观，长远一点的东西来配合程序计数器，这就是——Java虚拟机栈。

当我们的线程调用一次方法（Native方法除外），就会被塞进来一个栈帧，栈帧中存放了一个方法执行所需的所有东西，其中包含**局部变量表、操作数栈、动态链接、方法返回地址**。

当一个方法执行完后，我们就会将栈帧弹出。

接下来我们试着去解释一下虚拟机栈的各个部分。

* 局部变量表：局部变量表存放该栈帧用到的所有局部变量（包含基本类型变量与对象引用类型的变量）。
* 动态链路：在方法的使用时，常常会出现一个方法调用另一个方法的过程，这一过程需要我们从常量池中的方法引用（就像方法指针一样），转化为内存地址中的直接引用，这一过程由动态链路完成，又被称为动态连接。
* 操作数栈：主要存放一些临时的变量（举个例子，我们再算1+1+1的过程其实是先算1+1=2，再算2+1=3，这一过程的2不会被一个局部变量表中的变量记住，因此就需要放到一个新的空间，即操作数栈）
* 操作返回地址：记录了当前方法执行完后/异常退出后应该去到什么地方

## 本地方法栈

与虚拟机栈并无很大的不同m'zhi
