# 垃圾回收机制

如果接触过C/C++的小伙伴应该知道，我们在申请了空间后一定要释放空间，不然就会有**内存泄漏**的风险，JVM通过自行完成这个操作来省去的程序员申请空间与释放空间的过程。

JVM会在认为一个对象实例不再被用到的时候将他回收掉

那么这里就引入一个新的机制 **垃圾回收机制——如何认定与回收对象**

## 对象存活判定算法

上轨线先来看看如何认为一个对象已经不会再被用到/如何认为一个对象已经可以被回收

### 引用计数法

当我们吹昂见一个对象，首先要创建一个他的引用变量

```java
String a="12334";  //这里的a是就是引用变量，表示变量"1234的应用"
```

这里就需要引入一个观念了:**我们操作的实际上都是变量的一个引用**

每个引用都会存放一给**引用计数器**

1. 当对象在一个地方被使用，则计数器+1
2. 当离开了引用失效（离开局部变量的作用域（也就是栈帧被推出），或者引用被设置为null）则-1
3. 当引用的计数为0时就不再被使用了

但是存在一种卡bug的行为

```java
String a= new Test();
String b= new Test();
a.inner=b;
b.innser=a;
a=b=null;

public class Test{
	Test inner;
}
```

此时有两个无法被清除的变量，就是a和b的inner，又因为a和b都被赋值为null了，所以我们也无法再去操作原本的那两个实例

### 可达性分析算法

可达性分析会认为没有根节点的对象就是可以被回收的，那么什么是根节点呢？

1. 栈帧中引用到的对象
2. 本地方法栈引用到的对象
3. 常量池里的对象
4. 被加了锁的对象
5. 虚拟机内部用到的对象

## 垃圾回收算法

提及垃圾回收就必须得先了解对象是如何存放的了。

在Java内存机制中我们曾提到过，Java的对象实际是存放在堆中的，那么堆究竟是什么样的呢？

堆大致分为新生代，老年代和永久代（后面修改为元空间）三个部分，三者大小大致为8：1：1，新生代又分为Eden和Survivor两个部分，Survivro内部含有to和from两个部分。

当对象第一次创建成功后就会被放在新生代的Eden中，等待GC的到来，第一次GC经历后，会剩余的对象放入Survivor的From区，然后交换一次to和From区（To变成From，From变成To）

接着经历第二次GC，再次将Eden