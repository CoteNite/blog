[极之心————计算机网络救急课堂](https://www.bilibili.com/video/BV1Ju4y157wh?spm_id_from=333.788.videopod.episodes&vd_source=9376a85d54558433ad7f11594f35ffa4)



## IPV4

IP地址：32位点分十进制  4 * 8 例如127.0.0.1就是4  8位二进制=255

IP地址=网络号+主机号

所以IP地址总共2的32次方个

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251210220042.png)


ABC类为单播地址，只有单播地址可以分配给主机各接口

主机号全为0的为网络地址，可做源地址，不可做目的地址

主机号全为1的为广播地址，不可做源地址，可做目的地址

A类地址：0.0.0.0~127.255.255.255 (127 = 01111111)

其中网络号为0的地址为本网络，不可指派，网络号为127的地址的为本地环回地址，不可指派

每个A类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个可指派的地址（除去全0和全1）


B类地址：128.0.0.0~191.255.255.255 

每个B类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个地址（除去全0和全1）(B类地址网络号16位)

全球网络中有三个特殊的地址块

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

这些是专用地址，可重用

c类地址：192.0.0.0~223.255.255.255

### 总结

对于所有的网络，主机号全为0的为本网络地址，主机号全为1的为广播地址，这两个特别的地址不可指派，网络地址可做源地址不可做目的地址，广播地址可做目的地址不可做源地址

A类：网络号为8位，开头必须为0，后面32位为主机号，内含`0.0.0.0~127.255.255.255`，主机号全为0或全为1即`x.0.0.0`或`x.255.255.255`，**特别的，A类中0或127开头的不可指派**

B类：网络号为16位，开头必须为10，后面16位为主机号，内含`128.0.0.0~191.255.255.255`，主机号全为0或全为1即`x.x.0.0`或`x.x.255.255`

C类：网络号为24位，开头必须为110，后面8位为主机号，内含`192.0.0.0~223.255.255.255`，主机号全为0或全为1即`x.x.x.0`或`x.x.x.255`

三个特别的地址块，专用/可重用，可指派：

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

## 子网划分

主要是即使是一个C类地址，一个也可以分配2的8次方-2个地址，很有可能一个公司用不完，因此需要子网划分

子网划分的核心为**子网掩码**

主要干的事就是将网络号+主机号的形式转变成网络号+子网号+主机号，用连续的比特1表示网络号和子网号，用连续的比特0表示主机号

子网掩码仍然是32为二进制，但原地址主机号部分全部用1（也就是255）表示

举个例子：

IP：180.80.77.55 子网掩码：255.255.252.0

其中子网掩码前16位为255，确认为b类网络，252=（11111100） 6位1即子网号为6位

77.55=（010011（子网号）  01.00110111）

该主机所在的子网的广播地址为

180.80.010011 11.1111111  -> 180.80.79.255

## 无分类的编制方法

当我们发现使用子网的情况下仍然太大时，我们就尝试是用了无分类的编制方法

**使用的是地址掩码**

用连续的比特1表示网络号，连续的0表示主机号，其中网络号的部分被称为CIDR地址块

举个例子：

地址掩码为255.255.240.0 -> 11111111 11111111 1111 | 0000 00000000

也就是20个1和12个0 即前20位为网络号，后12位为主机号

再看回其对应的IP地址——128.14.35.7

(10000000 00001110 0010)网络号 (0011 00000111)主机号

另一种写法就是 `x.x.x.x/y` 其中的y就是网络号的位数

## 掩码的总结

掩码是对IP地址的一个解释，其连续的1的数量和0的数量使用来区分IP地址中的哪些位是网络号，哪些是主机号，子网号

因此首要的操作肯定是将掩码转换成二进制，进而根据掩码中连续为1的位数去锁定ip中的位置，这一部分就是IP的网络号（+子网号），0的部分则是主机号

得到网络号的部分，我们就可以将其固定，然后剩下的部分就可以推得到其网络地址和广播地址

## IPV6

IPV4 -> IPV6  使用了双协议栈技术+隧道技术

IPV6的地址用128位冒号16进制表示，也就是8组，每组4个

ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

由于过于难表示，因此采用`左侧0省略`+`连续0压缩`的方式表示

FE80: 0000:0000:0000:AAAA:00C2:00C2:0002

左侧0省略： 0:0:0:AAAA:0C2:0C2:02

连续0压缩： :: AAA :0C2:0C2:02  (也就是连续的0全部压缩为::)


值得一提的是连续0压缩可以用在IPV6的任何位置，但是只能使用一次，因此我们一边用在连续0最多的地方

   12AB:0000:0000:CD30:0000:0000:0000:0000
-> 12AB:0:0:CD30::

## RIP距离向量算法

现有路由器A收到如下的项目

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184238.png)

并受到C发来的路由

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184257.png)


第一步就是先将所有的C发来的信息更改为A视角的信息，即保留目的网络不变，所有到目的网络的距离+1（因为认为A收到C的信息，即C与A相邻，即距离为1），并将下一跳转换为C

然后与原本A的项目比较

1. 如果下一跳相同，但信息不同，则更新为A原有的
2. 如果下一跳不同，比长短，保留（A原有的）/更新（C现传的）为短的
3. 如果存在新项目，直接添加

## 协议首部

### IPV4的协议首部

总共占用20字节：

- 版本：占用4位，存协议版本，比如IPV4版本为4
- 首部长度：占用4位，表示整个首部的长度，单位是每4字节，也就是说首部长度为5，实际上表示首部有20字节
- 区分服务：占用8位
- 总长度，占用16位，首部+数据部分的总长度
- 标识：占用16位，类似计数器，产生了几个数据包，**所有分片的标识一致**
- 标志：占用3位，有三种状态，每一位代表一个状态，但其实只有两个有效的状态，即MF（More Fragment）和DF（Don't Fragment）表示数据包是否后续还有分片以及是否允许分片。针对DF位，**DF位的0和1的标准不是是否分片，而是是否可以分片**，能分片的数据就是0，1是特别的不允许分片的数据
- 片偏移：占用13位，表示该分片在原本整体中处于第几片的位置，分片的`起始位置/8`为片偏移（比如某一片的第一位为原数据的第1400位，则为1400/8=175），也就是以8字节为单位，这意味着每个分片的大小必须是8的倍数，没分片和第一片的片偏移为0
- 生存时间：占用8位，表示在传输过程中最大的存活时间
- 协议（号）：占用8位，每个协议固定的号，占用8位
- 首部检验和：占用16位，用来检验是否与误码
- 源地址：占用32位，表示发送数据包的源地址
- 目的地址：占用32位，表示接受数据包的目的地址

MTU：数据报的最大长度（包含首部）

当MTU最大化利用的情况下片偏移非整数时，则使用可以被整除的最大部分（即每个分片为最大的可被8整除的数，且分片数还要最少）

### IPV6的协议首部

IPV6的首部为60字节：

|            **字段名称**            | **占用位数** |                                                  **作用和描述**                                                   |                **类似 IPv4 字段**                |
| :----------------------------: | :------: | :----------------------------------------------------------------------------------------------------------: | :------------------------------------------: |
|        **版本 (Version)**        |   4 位    |                                              版本号固定为 6 (`0110`)。                                              |                      版本                      |
|    **通信量类 (Traffic Class)**    |   8 位    |                              用于标记数据报的优先级和区分服务，支持 **QoS (Quality of Service)**。                               |               区分服务 (DS Field)                |
|      **流标号 (Flow Label)**      |   20 位   |            $\text{IPv6}$ 新增字段。用于标识属于同一“流”（$\text{Flow}$）的数据报集合，路由器可以对同一流的数据报进行**快速处理**，类似于对流打标签。             |  **无直接对应** (但与 $\text{IPv4}$ 的标识用于分片的目的不同)   |
|  **有效载荷长度 (Payload Length)**   |   16 位   |                           表示 $\text{IPv6}$ 首部**之后**的字节长度，包括**扩展首部**和**上层数据**的总长度。                            | 总长度 (Total Length) **减去** $\text{IPv4}$ 首部长度 |
|    **下一个首部 (Next Header)**     |   8 位    | 用于识别 $\text{IPv6}$ 首部之后的**扩展首部类型**，或指示紧跟在 $\text{IPv6}$ 首部后面的**上层协议**（如 $\text{TCP}$ 为 6，$\text{UDP}$ 为 17）。 |                协议 (Protocol)                 |
|      **跳限制 (Hop Limit)**       |   8 位    |                       功能与 $\text{IPv4}$ 的 $\text{TTL}$ 字段完全一样。每经过一个路由器减 1，减到 0 则丢弃数据报。                       |                  生存时间 (TTL)                  |
|    **源地址 (Source Address)**    |  128 位   |                                            发送方 $\text{IPv6}$ 地址。                                             |                     源地址                      |
| **目的地址 (Destination Address)** |  128 位   |                                            接收方 $\text{IPv6}$ 地址。                                             |                     目的地址                     |

## UDP首部

UDP数据报总共8个字节

- 源端口号：2字节
- 目的端口号：2字节
- 长度：2字节
- 校验和：2字节

## TCP首部

**可靠的面向字节流的传输协议**

TCP的首部总共二十字节：

- 源端口：16位，表示发送方进程的端口号
- 目的端口：16位，表示接收方进程的端口号
- 序号：32位/4字节，0~2的32次方-1，逐渐递增，用于给传递的字节流编号，在连接建立后，序号是按字节计算的，用于实现可靠传输和乱序重排。
- 确认号：32位/4字节，表示发送方**期望收到**的对方的**下一个报文段的数据的第一个字节的序号**。例如，如果收到的报文段数据字节到 $X$ 结束，则确认号为 $X+1$。
- 数据偏移：4位，**以 4 字节（32 位）为单位**计算的 **TCP 首部长度**，该字段的最小值是 $5$（即 $5 \times 4 = 20$ 字节的标准首部），最大值是 $15$（即 $15 \times 4 = 60$ 字节，包含 40 字节的可选项）。
- 保留：6位，一段保留空间，全为0
- URG字段（urgent）：1位，为1时，紧急指针字段生效，用于存放紧急处理的信息
- ACK字段（acknowledge）：1位，为1时，表示确认号有效，否则确认号内容无效，所有建立连接后的传输都必须将 ACK 置为 $1$
- PSH字段（push）：1位，为 $1$ 时，接收方应**立刻**将报文段内的数据交给**应用层**，而不用等待整个缓冲区满。
- RST字段（rest）：1位，为 $1$ 时，表示连接出现严重错误或非法连接，请求**立即释放连接**并重新建立
- SYN字段（synchronized）：1位，为 $1$ 时表示**请求建立连接**（握手阶段使用），同时会设置一个初始序号。
- FIN字段（finish）：1位，为 $1$ 时表示**请求释放连接**（挥手阶段使用），数据发送完毕。
- 窗口：允许对方发送量，表示表示**发送方**愿意接收的**数据字节数**，用于进行**流量控制**。该值是从确认号算起。
- 检验和：1位，只有 URG 为 $1$ 时有效，指示紧急数据**末尾**相对于序号的偏移量。
- 紧急指针：16 位，与URG搭配，用于存放紧急处理的信息

## TCP的连接与释放

**三次握手与四次挥手**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251212183915.png)


TCP是双端连接，因此存在一个客户端一个服务器，服务器是被动打开，用来监听客户端是否主动打开链接

第一次握手：客户端：将SYN置为1，同时发送一个信号（seq=x，seq表示初始序号，此处为客户端的初始序号），本次报文用于建立连接，不允许携带信息

第二次握手：服务端：SYN为1，ACK为1，seq=y（服务端的初始序号），ack=x+1（ack为确认号）

第三次握手：客户端：ACK=1，seq=x+1（服务端希望的序号），ack=y+1（同时对服务端发送的序号+1）

**三次握手是为了防止客户端发送的请求报文延迟到达**

