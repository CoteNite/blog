
## 基础知识部分

[计网期末串讲](https://www.bilibili.com/video/BV1Vv411p7Sn?spm_id_from=333.788.player.switch&vd_source=9376a85d54558433ad7f11594f35ffa4)

## 概述

互联网由主机，网络，路由器组成，其中计网**核心在于路由器和网络**

### 端到端的两种方式

- 客户端-服务器模式：客户端向服务端请求服务，服务器响应服务
- p2p/端到端模式：不区分服务端和客户端，只要二者连接，就可以对等的通信
### 互联网核心部分

**路由器如何将内容转发？**

路由器要实现：

- 转发分组
- 路由器之间不断交换路由信息


### 经典的交换技术

- 电路交换：预先在通信前建立连接，一条通道直达，bit流直达终点
- 报文交换：通过报文，经过节点转发
- 分组交换：将个报文分段转发

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216124405.png)

![xxx](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216124606.png)

### 时延

时延由发送时延，传播时延，处理时延，排队时延四种

发送时延=数据帧长度/发送速率

传播时延=信道长度/电磁波在信道上传播的速度

### 利用率

当信道利用率增大时，信道的时延也会增大

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216191010.png)

上图中的D和D0都是时延，其中D0为空闲时延，进而可以得出利用率U

### 协议

网络协议，简称为协议，是为进行网络中的数据交换建立的规则，标准或规定

- 语法：网络协议的结构
- 语义：网络协议需要发出什么信息，完成什么规定
- 同步：事件实现顺序的详细说明

协议会分成多个层次以便实现更高的灵活性

### 五层协议

目前主要采用的是五层的协议

- 物理层：屏蔽传输媒体的区别（硬件上的区别）
- 数据链路层：解决三个问题————封装成帧，透明传输，差错检验
- 网络层：为分组交换的网上的不同主机提供通信服务
- 运输层：向两台主机中进程之间的通信提供服务
- 应用层：进程之间的交互实现

### 协议与层次

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216192525.png)


## 物理层

- 单工：A单向向B通信
- 半双工：AB可以互发，但不可以同时发，也不能同时收
- 全双工：通信双方可以同时发也可以同时收

### 两类传输媒体

- 导引类：电缆，光纤
- 非导引类：电磁波

### 信道复用好处

允许用户是由一个共享信道来通信，节约成本，提高利用率

### 四种信道复用技术

- 频分复用/FDM：将宽带分为多份，用户使用固定的频带进行通信
- 时分复用/TDM：将一段时间分为多个帧，每个帧用的用户都不一样，整体程周期性出现
- 统计时分复用/STDM：根据需求按需拆分时间，动态分配时隙
![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216193347.png)
- 波分复用/WDM：通过复用器和分用器实现光的频分复用
- 码分复用/CDM：不同的用户使用不同的码型，频率类似白噪声，更加隐蔽

码分复用的原理：CDM给每个用户分配的码序列各不相同且相互正交，所谓正交就是两个码的规格化内积为0，任何一个码片的向量与自己规格化内积都为1，与反码规格化内积都为-1

码分复用的好处：抗干扰能力强

码分复用的缺点：占用的带宽较大

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216194521.png)

对于规格化内积，如果结果为-1则认为发了0，结果为1则认为是1，如果为0则认为没发

### ADSL技术

对原有的电话线进行改造，使其拥有承担网络通信的能力

### HFC/光纤同轴混合网

对有限电视网进行改造

### FTTx技术

使用光纤直接接入到用户的家

### 信道

信道特指一个方向的媒体传输，与电路并不等同，一条通信电路往往包含一条发送信道和一条接受信道

### 调制的基本概念

定义：将信号源的信息进行处理加到载波上，然后就可以利于信道的传输

理由：电脑产生的为基带信号，并不适用于信道（往往含有很多的低频成分和直流成分）

调制的分类：
- 带通调制：使用载波进行调制，把基带信号的频率搬到较高的频段（使用高频载波进行调制），并转换为模拟信号以实现更好的传输，基本方法包括————调幅，调频，调相
- 基带调制：仅对基带的波形进行变化，进而使其频率发生变化，使其可以适应基带的传输

### 物理层的主要任务

**屏蔽掉不同的媒体和通信手段导致的差异，确定与传输媒体接口的一些特性**

- 机械特性：指明接口所用的接线器的形状，尺寸，引线数目等物理性状方面的特征
- 电气特性：电压相关
- 功能特性：某一电平电压的具体意义
- 过程特性：指明事件出现的顺序

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216201007.png)

## 数据链路层

数据链路层使用的两种信道：

- 点对点：AB一对一进行通信
- 广播信道：一对多进行通信，多个端公用一条信道进行通信，一个端向多个端发送信息

### 帧

点对点信道的数据链路层的协议单元

### 数据链路层的三个基本功能

### 封装成帧

- 概念：在一段数据的前后分别添加帧首部和帧尾部，进而构建出一个帧
- 目的：接受端在收到物理层上交流的比特流之后，可根据首部和尾部的标记，识别帧的开始和结束
- MTU：数据链路层协议规定的所能传输的帧的数据部分长度的上限————最大传输单元MTU

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216201750.png)

如果不封装成帧的问题：

会不知道bit流的开始与结束

Q：如果不封装成帧会发生什么

A：接收端收到数据后会不知道哪些是数据，哪些是控制信息，数据在传输过程中是否会出错；接收端由于不知道数据是否结束而不知道是否要把数据传递给上层

### 透明传输

无论发送什么样的比特组合的数据，这些数据都能按照原样没有差错的通过这个数据链路层

通俗意义：假设一个帧的数据部分中出现了侦首部的片段（因为是bit流，都是0/1，很容易出现重复片段），这时应该避免将这一部分误认为帧的开始/帧首部，这个操作/实现，就称之为透明传输

- 无比特差错：接收端会受到有差错和无差错的帧，但是接收端会主动丢弃掉出现差错的帧
- 无传输差错：即可靠传输，接收端只会受到无差错，不丢弃，不重复，按序到达的帧


PPP协议的格式：



### 







## 习题部分

[极之心————计算机网络救急课堂](https://www.bilibili.com/video/BV1Ju4y157wh?spm_id_from=333.788.videopod.episodes&vd_source=9376a85d54558433ad7f11594f35ffa4)

## IPV4

IP地址：32位点分十进制  4 * 8 例如127.0.0.1就是4  8位二进制=255

IP地址=网络号+主机号

所以IP地址总共2的32次方个

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251210220042.png)


ABC类为单播地址，只有单播地址可以分配给主机各接口

主机号全为0的为网络地址，可做源地址，不可做目的地址

主机号全为1的为广播地址，不可做源地址，可做目的地址

A类地址：0.0.0.0~127.255.255.255 (127 = 01111111)

其中网络号为0的地址为本网络，不可指派，网络号为127的地址的为本地环回地址，不可指派

每个A类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个可指派的地址（除去全0和全1）


B类地址：128.0.0.0~191.255.255.255 

每个B类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个地址（除去全0和全1）(B类地址网络号16位)

全球网络中有三个特殊的地址块

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

这些是专用地址，可重用

c类地址：192.0.0.0~223.255.255.255

### 总结

对于所有的网络，主机号全为0的为本网络地址，主机号全为1的为广播地址，这两个特别的地址不可指派，网络地址可做源地址不可做目的地址，广播地址可做目的地址不可做源地址

A类：网络号为8位，开头必须为0，后面32位为主机号，内含`0.0.0.0~127.255.255.255`，主机号全为0或全为1即`x.0.0.0`或`x.255.255.255`，**特别的，A类中0或127开头的不可指派**

B类：网络号为16位，开头必须为10，后面16位为主机号，内含`128.0.0.0~191.255.255.255`，主机号全为0或全为1即`x.x.0.0`或`x.x.255.255`

C类：网络号为24位，开头必须为110，后面8位为主机号，内含`192.0.0.0~223.255.255.255`，主机号全为0或全为1即`x.x.x.0`或`x.x.x.255`

三个特别的地址块，专用/可重用，可指派：

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

## 子网划分

主要是即使是一个C类地址，一个也可以分配2的8次方-2个地址，很有可能一个公司用不完，因此需要子网划分

子网划分的核心为**子网掩码**

主要干的事就是将网络号+主机号的形式转变成网络号+子网号+主机号，用连续的比特1表示网络号和子网号，用连续的比特0表示主机号

子网掩码仍然是32为二进制，但原地址主机号部分全部用1（也就是255）表示

举个例子：

IP：180.80.77.55 子网掩码：255.255.252.0

其中子网掩码前16位为255，确认为b类网络，252=（11111100） 6位1即子网号为6位

77.55=（010011（子网号）  01.00110111）

该主机所在的子网的广播地址为

180.80.010011 11.1111111  -> 180.80.79.255

## 无分类的编制方法

当我们发现使用子网的情况下仍然太大时，我们就尝试是用了无分类的编制方法

**使用的是地址掩码**

用连续的比特1表示网络号，连续的0表示主机号，其中网络号的部分被称为CIDR地址块

举个例子：

地址掩码为255.255.240.0 -> 11111111 11111111 1111 | 0000 00000000

也就是20个1和12个0 即前20位为网络号，后12位为主机号

再看回其对应的IP地址——128.14.35.7

(10000000 00001110 0010)网络号 (0011 00000111)主机号

另一种写法就是 `x.x.x.x/y` 其中的y就是网络号的位数

## 掩码的总结

掩码是对IP地址的一个解释，其连续的1的数量和0的数量使用来区分IP地址中的哪些位是网络号，哪些是主机号，子网号

因此首要的操作肯定是将掩码转换成二进制，进而根据掩码中连续为1的位数去锁定ip中的位置，这一部分就是IP的网络号（+子网号），0的部分则是主机号

得到网络号的部分，我们就可以将其固定，然后剩下的部分就可以推得到其网络地址和广播地址

## IPV6

IPV4 -> IPV6  使用了双协议栈技术+隧道技术

IPV6的地址用128位冒号16进制表示，也就是8组，每组4个

ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

由于过于难表示，因此采用`左侧0省略`+`连续0压缩`的方式表示

FE80: 0000:0000:0000:AAAA:00C2:00C2:0002

左侧0省略： 0:0:0:AAAA:0C2:0C2:02

连续0压缩： :: AAA :0C2:0C2:02  (也就是连续的0全部压缩为::)


值得一提的是连续0压缩可以用在IPV6的任何位置，但是只能使用一次，因此我们一边用在连续0最多的地方

   12AB:0000:0000:CD30:0000:0000:0000:0000
-> 12AB:0:0:CD30::

## RIP距离向量算法

现有路由器A收到如下的项目

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184238.png)

并受到C发来的路由

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184257.png)


第一步就是先将所有的C发来的信息更改为A视角的信息，即保留目的网络不变，所有到目的网络的距离+1（因为认为A收到C的信息，即C与A相邻，即距离为1），并将下一跳转换为C

然后与原本A的项目比较

1. 如果下一跳相同，但信息不同，则更新为A原有的
2. 如果下一跳不同，比长短，保留（A原有的）/更新（C现传的）为短的
3. 如果存在新项目，直接添加

## 协议首部

### IPV4的协议首部

总共占用20字节：

- 版本：占用4位，存协议版本，比如IPV4版本为4
- 首部长度：占用4位，表示整个首部的长度，单位是每4字节，也就是说首部长度为5，实际上表示首部有20字节
- 区分服务：占用8位
- 总长度，占用16位，首部+数据部分的总长度
- 标识：占用16位，类似计数器，产生了几个数据包，**所有分片的标识一致**
- 标志：占用3位，有三种状态，每一位代表一个状态，但其实只有两个有效的状态，即MF（More Fragment）和DF（Don't Fragment）表示数据包是否后续还有分片以及是否允许分片。针对DF位，**DF位的0和1的标准不是是否分片，而是是否可以分片**，能分片的数据就是0，1是特别的不允许分片的数据
- 片偏移：占用13位，表示该分片在原本整体中处于第几片的位置，分片的`起始位置/8`为片偏移（比如某一片的第一位为原数据的第1400位，则为1400/8=175），也就是以8字节为单位，这意味着每个分片的大小必须是8的倍数，没分片和第一片的片偏移为0
- 生存时间：占用8位，表示在传输过程中最大的存活时间
- 协议（号）：占用8位，每个协议固定的号，占用8位
- 首部检验和：占用16位，用来检验是否与误码
- 源地址：占用32位，表示发送数据包的源地址
- 目的地址：占用32位，表示接受数据包的目的地址

MTU：数据报的最大长度（包含首部）

当MTU最大化利用的情况下片偏移非整数时，则使用可以被整除的最大部分（即每个分片为最大的可被8整除的数，且分片数还要最少）

### IPV6的协议首部

IPV6的首部为60字节：

|            **字段名称**            | **占用位数** |                                                  **作用和描述**                                                   |                **类似 IPv4 字段**                |
| :----------------------------: | :------: | :----------------------------------------------------------------------------------------------------------: | :------------------------------------------: |
|        **版本 (Version)**        |   4 位    |                                              版本号固定为 6 (`0110`)。                                              |                      版本                      |
|    **通信量类 (Traffic Class)**    |   8 位    |                              用于标记数据报的优先级和区分服务，支持 **QoS (Quality of Service)**。                               |               区分服务 (DS Field)                |
|      **流标号 (Flow Label)**      |   20 位   |            $\text{IPv6}$ 新增字段。用于标识属于同一“流”（$\text{Flow}$）的数据报集合，路由器可以对同一流的数据报进行**快速处理**，类似于对流打标签。             |  **无直接对应** (但与 $\text{IPv4}$ 的标识用于分片的目的不同)   |
|  **有效载荷长度 (Payload Length)**   |   16 位   |                           表示 $\text{IPv6}$ 首部**之后**的字节长度，包括**扩展首部**和**上层数据**的总长度。                            | 总长度 (Total Length) **减去** $\text{IPv4}$ 首部长度 |
|    **下一个首部 (Next Header)**     |   8 位    | 用于识别 $\text{IPv6}$ 首部之后的**扩展首部类型**，或指示紧跟在 $\text{IPv6}$ 首部后面的**上层协议**（如 $\text{TCP}$ 为 6，$\text{UDP}$ 为 17）。 |                协议 (Protocol)                 |
|      **跳限制 (Hop Limit)**       |   8 位    |                       功能与 $\text{IPv4}$ 的 $\text{TTL}$ 字段完全一样。每经过一个路由器减 1，减到 0 则丢弃数据报。                       |                  生存时间 (TTL)                  |
|    **源地址 (Source Address)**    |  128 位   |                                            发送方 $\text{IPv6}$ 地址。                                             |                     源地址                      |
| **目的地址 (Destination Address)** |  128 位   |                                            接收方 $\text{IPv6}$ 地址。                                             |                     目的地址                     |

## UDP首部

UDP数据报总共8个字节

- 源端口号：2字节
- 目的端口号：2字节
- 长度：2字节
- 校验和：2字节

## TCP首部

**可靠的面向字节流的传输协议**

TCP的首部总共二十字节：

- 源端口：16位，表示发送方进程的端口号
- 目的端口：16位，表示接收方进程的端口号
- 序号：32位/4字节，0~2的32次方-1，逐渐递增，用于给传递的字节流编号，在连接建立后，序号是按字节计算的，用于实现可靠传输和乱序重排。
- 确认号：32位/4字节，表示发送方**期望收到**的对方的**下一个报文段的数据的第一个字节的序号**。例如，如果收到的报文段数据字节到 $X$ 结束，则确认号为 $X+1$。
- 数据偏移：4位，**以 4 字节（32 位）为单位**计算的 **TCP 首部长度**，该字段的最小值是 $5$（即 $5 \times 4 = 20$ 字节的标准首部），最大值是 $15$（即 $15 \times 4 = 60$ 字节，包含 40 字节的可选项）。
- 保留：6位，一段保留空间，全为0
- URG字段（urgent）：1位，为1时，紧急指针字段生效，用于存放紧急处理的信息
- ACK字段（acknowledge）：1位，为1时，表示确认号有效，否则确认号内容无效，所有建立连接后的传输都必须将 ACK 置为 $1$
- PSH字段（push）：1位，为 $1$ 时，接收方应**立刻**将报文段内的数据交给**应用层**，而不用等待整个缓冲区满。
- RST字段（rest）：1位，为 $1$ 时，表示连接出现严重错误或非法连接，请求**立即释放连接**并重新建立
- SYN字段（synchronized）：1位，为 $1$ 时表示**请求建立连接**（握手阶段使用），同时会设置一个初始序号。
- FIN字段（finish）：1位，为 $1$ 时表示**请求释放连接**（挥手阶段使用），数据发送完毕。
- 窗口：允许对方发送量，表示表示**发送方**愿意接收的**数据字节数**，用于进行**流量控制**。该值是从确认号算起。
- 检验和：1位，只有 URG 为 $1$ 时有效，指示紧急数据**末尾**相对于序号的偏移量。
- 紧急指针：16 位，与URG搭配，用于存放紧急处理的信息

## TCP的连接与释放

**三次握手与四次挥手**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251212183915.png)


TCP是双端连接，因此存在一个客户端一个服务器，服务器是被动打开，用来监听客户端是否主动打开链接

第一次握手：客户端：将SYN置为1，同时发送一个信号（seq=x，seq表示初始序号，此处为客户端的初始序号），本次报文用于建立连接，不允许携带信息

第二次握手：服务端：SYN为1，ACK为1，seq=y（服务端的初始序号），ack=x+1（ack为确认号）

第三次握手：客户端：ACK=1，seq=x+1（服务端希望的序号），ack=y+1（同时对服务端发送的序号+1）

**三次握手是为了防止客户端发送的请求报文延迟到达**

