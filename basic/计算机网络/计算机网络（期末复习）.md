
## 基础知识部分

[计网期末串讲](https://www.bilibili.com/video/BV1Vv411p7Sn?spm_id_from=333.788.player.switch&vd_source=9376a85d54558433ad7f11594f35ffa4)

## 概述

互联网由主机，网络，路由器组成，其中计网**核心在于路由器和网络**

### 端到端的两种方式

- 客户端-服务器模式：客户端向服务端请求服务，服务器响应服务
- p2p/端到端模式：不区分服务端和客户端，只要二者连接，就可以对等的通信
### 互联网核心部分

**路由器如何将内容转发？**

路由器要实现：

- 转发分组
- 路由器之间不断交换路由信息


### 经典的交换技术

- 电路交换：预先在通信前建立连接，一条通道直达，bit流直达终点
- 报文交换：通过报文，经过节点转发
- 分组交换：将个报文分段转发

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216124405.png)

![xxx](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216124606.png)

### 时延

时延由发送时延，传播时延，处理时延，排队时延四种

发送时延=数据帧长度/发送速率

传播时延=信道长度/电磁波在信道上传播的速度

### 利用率

当信道利用率增大时，信道的时延也会增大

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216191010.png)

上图中的D和D0都是时延，其中D0为空闲时延，进而可以得出利用率U

### 协议

网络协议，简称为协议，是为进行网络中的数据交换建立的规则，标准或规定

- 语法：网络协议的结构
- 语义：网络协议需要发出什么信息，完成什么规定
- 同步：事件实现顺序的详细说明

协议会分成多个层次以便实现更高的灵活性

### 五层协议

目前主要采用的是五层的协议

- 物理层：屏蔽传输媒体的区别（硬件上的区别）
- 数据链路层：解决三个问题————封装成帧，透明传输，差错检验
- 网络层：为分组交换的网上的不同主机提供通信服务
- 运输层：向两台主机中进程之间的通信提供服务
- 应用层：进程之间的交互实现

### 协议与层次

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216192525.png)


## 物理层

- 单工：A单向向B通信
- 半双工：AB可以互发，但不可以同时发，也不能同时收
- 全双工：通信双方可以同时发也可以同时收

### 两类传输媒体

- 导引类：电缆，光纤
- 非导引类：电磁波

### 信道复用好处

允许用户是由一个共享信道来通信，节约成本，提高利用率

### 四种信道复用技术

- 频分复用/FDM：将宽带分为多份，用户使用固定的频带进行通信
- 时分复用/TDM：将一段时间分为多个帧，每个帧用的用户都不一样，整体程周期性出现
- 统计时分复用/STDM：根据需求按需拆分时间，动态分配时隙
![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216193347.png)
- 波分复用/WDM：通过复用器和分用器实现光的频分复用
- 码分复用/CDM：不同的用户使用不同的码型，频率类似白噪声，更加隐蔽

码分复用的原理：CDM给每个用户分配的码序列各不相同且相互正交，所谓正交就是两个码的规格化内积为0，任何一个码片的向量与自己规格化内积都为1，与反码规格化内积都为-1

码分复用的好处：抗干扰能力强

码分复用的缺点：占用的带宽较大

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216194521.png)

对于规格化内积，如果结果为-1则认为发了0，结果为1则认为是1，如果为0则认为没发

### ADSL技术

对原有的电话线进行改造，使其拥有承担网络通信的能力

### HFC/光纤同轴混合网

对有限电视网进行改造

### FTTx技术

使用光纤直接接入到用户的家

### 信道

信道特指一个方向的媒体传输，与电路并不等同，一条通信电路往往包含一条发送信道和一条接受信道

### 调制的基本概念

定义：将信号源的信息进行处理加到载波上，然后就可以利于信道的传输

理由：电脑产生的为基带信号，并不适用于信道（往往含有很多的低频成分和直流成分）

调制的分类：
- 带通调制：使用载波进行调制，把基带信号的频率搬到较高的频段（使用高频载波进行调制），并转换为模拟信号以实现更好的传输，基本方法包括————调幅，调频，调相
- 基带调制：仅对基带的波形进行变化，进而使其频率发生变化，使其可以适应基带的传输

### 物理层的主要任务

**屏蔽掉不同的媒体和通信手段导致的差异，确定与传输媒体接口的一些特性**

- 机械特性：指明接口所用的接线器的形状，尺寸，引线数目等物理性状方面的特征
- 电气特性：电压相关
- 功能特性：某一电平电压的具体意义
- 过程特性：指明事件出现的顺序

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216201007.png)

## 数据链路层

数据链路层使用的两种信道：

- 点对点：AB一对一进行通信
- 广播信道：一对多进行通信，多个端公用一条信道进行通信，一个端向多个端发送信息

### 帧

点对点信道的数据链路层的协议单元

### 数据链路层的三个基本功能/问题

### 封装成帧

- 概念：在一段数据的前后分别添加帧首部和帧尾部，进而构建出一个帧
- 目的：接受端在收到物理层上交流的比特流之后，可根据首部和尾部的标记，识别帧的开始和结束
- MTU：数据链路层协议规定的所能传输的帧的数据部分长度的上限————最大传输单元MTU

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216201750.png)

如果不封装成帧的问题：

会不知道bit流的开始与结束

Q：如果不封装成帧会发生什么

A：接收端收到数据后会不知道哪些是数据，哪些是控制信息，数据在传输过程中是否会出错；接收端由于不知道数据是否结束而不知道是否要把数据传递给上层

### 透明传输

无论发送什么样的比特组合的数据，这些数据都能按照原样没有差错的通过这个数据链路层

通俗意义：假设一个帧的数据部分中出现了侦首部的片段（因为是bit流，都是0/1，很容易出现重复片段），这时应该避免将这一部分误认为帧的开始/帧首部，这个操作/实现，就称之为透明传输

- 无比特差错：接收端会受到有差错和无差错的帧，但是接收端会主动丢弃掉出现差错的帧
- 无传输差错：即可靠传输，接收端只会受到无差错，不丢弃，不重复，按序到达的帧（网络层和数据链路层无需实现（特别注意，是不要求，不是不可以））

### 差错检验

测和纠正数据在传输过程中产生的错误 (比特错误)，确保数据可靠性

利用循环冗余检验 (CRC) 等方法生成校验码，接收端通过校验码判断帧是否有错。

### PPP

**目前使用的最广泛的数据链路层协议，针对点对点通信**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216203103.png)

- FCS：用于实现CRC冗余检验
- MTU：1500字节

一些关键信息：

- PPP基于IP
- 实现了封装成帧，透明传输，差错检验（三大基本功能）
- 能在一条物理链路上支持多种网络层协议
- 能够在多种类型的链路上运行
- PPP不使用帧的编号，这是因为数据链路层不需要实现可靠传输，也就不需要帧的有序发送
- 适用于通信线路较好的情况，这是因为没有实现可靠传输，因此只能通过较好的通信线路来保证丢弃较少
- PPP不提供可靠传输

PPP解决透明传输的两种方法：
- 当PPP用在异步传输的时候会使用一种特殊的字符进行填充
- 当PPP用在同步传输链路的时候，协议会采用硬件来完成比特填充

**字符填充：**
1. 单字节的0x7E转换为两字节的0x7D，0x5E（0x7D充当转义字符）
2. 出现0x7D转化为两字节的0x7D，0x5D（用转义+0x5D充当原本的0x7D）
3. 出现了ASCII码的控制字符（即数值小于0x20的字符），**先在前面加 `0x7D`，然后将该字符与 `0x20` 进行异或（XOR）运算**。例如：出现 `0x03`（ETX），会变成 `0x7D, 0x23`（因为 $0x03 \oplus 0x20 = 0x23$

**零比特填充：**
- 发送端出现五个连续的1则立刻填充0
- 接收端对帧的比特流进行扫描，每出现五个连续的1则删除后面紧跟的一个0


### 数据链路层要实现可靠有何好处和缺点

增加了可靠性（早发现早纠正），牺牲了实时性（协议变得复杂，计算困难，传输效率变慢，这是最致命的，因为大多数情况要求数据链路层速度够快）

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216205159.png)


### 数据链路层的三大基本问题的原因/为什么要加以解决

- 封装成帧：接收端在收到物理层的比特流之后要通过帧首帧尾来确定帧的开始和结束
- 透明传输：保证无论出现什么样的比特组合都可以无差错的通过数据链路层（这里的**任何**其实一般是指帧首和帧尾使用的比特组合）
- 差错检验：使网络中的节点早点发现错误，进而减少对网络资源的浪费

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216205507.png)

### 局域网的数据链路层

通过一个站点通过**广播**的形式实现消息的传递

- 局域网的特点：网络为一个单位所有，物理范围和站点数目都有限
- 局域网的优点：具有广播功能，从一个站点可以方便的访问全网，局域网上的主机可以共享连接在局域网上的各种硬件和软件资源



Q:局域网为什么采用广播通信？

A：因为站点数目有限，物理范围有限，所以可以从一个站点方便的访问全网资源

Q:为什么广域网不用广播通信？

A：站点数目和物理范围范围太大，造成碰撞的概率过大，导致通信资源的浪费

### 以太网的两个标准

DIX Ethernet V2  和  IEEE 802.3

### 适配器

适配器 ~= 网卡

作用：
- 实现计算机内部的并行数据与外部互联网的串行数据的转换
- 缓存外部传入的数据
- 实现数据驱动
- 实现以太网协议

使用与物理层与数据链路层

### CSMA/CD协议

针对广播，用于规避广播中出现的碰撞

- 含义——CSMA/CD的翻译：载波监听多点接入/碰撞检测
- 载波监听：不管在发送前，发送中都要监听站点的状态，防止在有人发送消息的时候发送
- 多点检测：说明这是总线型网络，计算机以多点接入的形式连接在一根总线上
- 碰撞检测：即边发送边监听，碰撞就是发生了冲突，因此也成为冲突检测

### CSMA/CD与时分复用的区别

当网络负载较轻（不容易发生冲突）的时候，CSMA/CD很灵活，想谁发送就谁发送，且碰撞概率较小，如果使用时分复用，由于很多站没有信息要发送，分配的时间就浪费了，因此效率较低，当网络负担比较重的时候，由于CSMA/CD引起的碰撞较多，因而效率较低，所以推荐使用TDM

### 以太网

一种基带总线的局域网，因为曾经使用的电磁波叫以太而得名，以太网中通过广播的形式进行传输

### MAC地址

硬件地址，固化在适配器中的地址，与IP地址进行区分

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216212049.png)

### 以太网交换机的自学习功能

以太网交换机内部会维护一个交换表，会将交换机的接口与MAC地址建立联系，进而实现在广播模式下的点对点信息发送，而以太网的自学习功能就是在以太网交换机中的某个接口更换了机子（MAC地址），那么以太网交换机会自动的维护交换表，进而实现以太网交换机的即插即用

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216212827.png)

### 以太网交换机的工作原理和特点，以太网交换机和转发器的区别

工作原理：以太网交换机本身实际上就是一个网桥，工作在数据链路层，根据MAC帧的目的地址对收到的帧进行转发和过滤

特点：多接口的网桥；工作在全双工的方式；具有并行性，能同时连接多个接口，使多对主机能同时通信，相互通信的主机都是独占传输媒体，无碰撞的传输数据，用户独享宽带，增加了总容量

与转发器：转发器工作在物理层，它仅简单地转发信号，没有过滤能力

### MAC帧格式

PPP帧针对于点对点，而MAC帧针对于广播信道

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216213353.png)

主要是通过目的地址和源地址来实现广播中的针对谁通信，类型是交给IP层用的

## `网络层` / `TCP/IP中的IP层`

### 是否实现可靠传输

实现不了，只是尽最大努力的交付数据报服务

### 虚拟互联网的意义

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216220102.png)

虚拟互联网和IP地址最大的好处是屏蔽掉了数据链路层中MAC地址导致的异构差异

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216220228.png)

### 分类IP地址/IPV4

分类的IP地址：32位，前面是网络号后面是主机号

分为五类地址，ABCDE

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217122335.png)

**点分十进制法**

对于一个32位的IP地址，可读性太差，因此我们以8位二进制为单位，将32位拆分成四个十进制数

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217123236.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217123336.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217124104.png)

- A类网中网络号除第一位以外全0的不指派，因为是本网络
- A类网中网络号除第一位以外全0的不指派，因为是本地环回地址
- 目前B类网的128.0可以指派，是最新的网络规则

### IP地址和硬件地址

硬件地址是数据链路层和物理层使用的，而IP地址是网络层以上使用的，IP地址本身是一个逻辑地址，通过软件实现

**计算机网络本身是一个层层封装的过程**

IP地址最大的意义就是去除硬件的异构性，CPU与存储器使用的就是IP地址

### IP数据报的格式

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217144428.png)




## 习题部分

[极之心————计算机网络救急课堂](https://www.bilibili.com/video/BV1Ju4y157wh?spm_id_from=333.788.videopod.episodes&vd_source=9376a85d54558433ad7f11594f35ffa4)

## IPV4

IP地址：32位点分十进制  4 * 8 例如127.0.0.1就是4  8位二进制=255

IP地址=网络号+主机号

所以IP地址总共2的32次方个

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251210220042.png)


ABC类为单播地址，只有单播地址可以分配给主机各接口

主机号全为0的为网络地址，可做源地址，不可做目的地址

主机号全为1的为广播地址，不可做源地址，可做目的地址

A类地址：0.0.0.0~127.255.255.255 (127 = 01111111)

其中网络号为0的地址为本网络，不可指派，网络号为127的地址的为本地环回地址，不可指派

每个A类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个可指派的地址（除去全0和全1）


B类地址：128.0.0.0~191.255.255.255 

每个B类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个地址（除去全0和全1）(B类地址网络号16位)

全球网络中有三个特殊的地址块

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

这些是专用地址，可重用

c类地址：192.0.0.0~223.255.255.255

### 总结

对于所有的网络，主机号全为0的为本网络地址，主机号全为1的为广播地址，这两个特别的地址不可指派，网络地址可做源地址不可做目的地址，广播地址可做目的地址不可做源地址

A类：网络号为8位，开头必须为0，后面32位为主机号，内含`0.0.0.0~127.255.255.255`，主机号全为0或全为1即`x.0.0.0`或`x.255.255.255`，**特别的，A类中0或127开头的不可指派**

B类：网络号为16位，开头必须为10，后面16位为主机号，内含`128.0.0.0~191.255.255.255`，主机号全为0或全为1即`x.x.0.0`或`x.x.255.255`

C类：网络号为24位，开头必须为110，后面8位为主机号，内含`192.0.0.0~223.255.255.255`，主机号全为0或全为1即`x.x.x.0`或`x.x.x.255`

三个特别的地址块，专用/可重用，可指派：

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

## 子网划分

主要是即使是一个C类地址，一个也可以分配2的8次方-2个地址，很有可能一个公司用不完，因此需要子网划分

子网划分的核心为**子网掩码**

主要干的事就是将网络号+主机号的形式转变成网络号+子网号+主机号，用连续的比特1表示网络号和子网号，用连续的比特0表示主机号

子网掩码仍然是32为二进制，但原地址主机号部分全部用1（也就是255）表示

举个例子：

IP：180.80.77.55 子网掩码：255.255.252.0

其中子网掩码前16位为255，确认为b类网络，252=（11111100） 6位1即子网号为6位

77.55=（010011（子网号）  01.00110111）

该主机所在的子网的广播地址为

180.80.010011 11.1111111  -> 180.80.79.255

## 无分类的编制方法

当我们发现使用子网的情况下仍然太大时，我们就尝试是用了无分类的编制方法

**使用的是地址掩码**

用连续的比特1表示网络号，连续的0表示主机号，其中网络号的部分被称为CIDR地址块

举个例子：

地址掩码为255.255.240.0 -> 11111111 11111111 1111 | 0000 00000000

也就是20个1和12个0 即前20位为网络号，后12位为主机号

再看回其对应的IP地址——128.14.35.7

(10000000 00001110 0010)网络号 (0011 00000111)主机号

另一种写法就是 `x.x.x.x/y` 其中的y就是网络号的位数

## 掩码的总结

掩码是对IP地址的一个解释，其连续的1的数量和0的数量使用来区分IP地址中的哪些位是网络号，哪些是主机号，子网号

因此首要的操作肯定是将掩码转换成二进制，进而根据掩码中连续为1的位数去锁定ip中的位置，这一部分就是IP的网络号（+子网号），0的部分则是主机号

得到网络号的部分，我们就可以将其固定，然后剩下的部分就可以推得到其网络地址和广播地址

## IPV6

IPV4 -> IPV6  使用了双协议栈技术+隧道技术

IPV6的地址用128位冒号16进制表示，也就是8组，每组4个

ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

由于过于难表示，因此采用`左侧0省略`+`连续0压缩`的方式表示

FE80: 0000:0000:0000:AAAA:00C2:00C2:0002

左侧0省略： 0:0:0:AAAA:0C2:0C2:02

连续0压缩： :: AAA :0C2:0C2:02  (也就是连续的0全部压缩为::)


值得一提的是连续0压缩可以用在IPV6的任何位置，但是只能使用一次，因此我们一边用在连续0最多的地方

   12AB:0000:0000:CD30:0000:0000:0000:0000
-> 12AB:0:0:CD30::

## RIP距离向量算法

现有路由器A收到如下的项目

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184238.png)

并受到C发来的路由

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184257.png)


第一步就是先将所有的C发来的信息更改为A视角的信息，即保留目的网络不变，所有到目的网络的距离+1（因为认为A收到C的信息，即C与A相邻，即距离为1），并将下一跳转换为C

然后与原本A的项目比较

4. 如果下一跳相同，但信息不同，则更新为A原有的
5. 如果下一跳不同，比长短，保留（A原有的）/更新（C现传的）为短的
6. 如果存在新项目，直接添加

## 协议首部

### IPV4的协议首部

总共占用20字节：

- 版本：占用4位，存协议版本，比如IPV4版本为4
- 首部长度：占用4位，表示整个首部的长度，单位是每4字节，也就是说首部长度为5，实际上表示首部有20字节
- 区分服务：占用8位
- 总长度，占用16位，首部+数据部分的总长度
- 标识：占用16位，类似计数器，产生了几个数据包，**所有分片的标识一致**
- 标志：占用3位，有三种状态，每一位代表一个状态，但其实只有两个有效的状态，即MF（More Fragment）和DF（Don't Fragment）表示数据包是否后续还有分片以及是否允许分片。针对DF位，**DF位的0和1的标准不是是否分片，而是是否可以分片**，能分片的数据就是0，1是特别的不允许分片的数据
- 片偏移：占用13位，表示该分片在原本整体中处于第几片的位置，分片的`起始位置/8`为片偏移（比如某一片的第一位为原数据的第1400位，则为1400/8=175），也就是以8字节为单位，这意味着每个分片的大小必须是8的倍数，没分片和第一片的片偏移为0
- 生存时间：占用8位，表示在传输过程中最大的存活时间
- 协议（号）：占用8位，每个协议固定的号，占用8位
- 首部检验和：占用16位，用来检验是否与误码
- 源地址：占用32位，表示发送数据包的源地址
- 目的地址：占用32位，表示接受数据包的目的地址

MTU：数据报的最大长度（包含首部）

当MTU最大化利用的情况下片偏移非整数时，则使用可以被整除的最大部分（即每个分片为最大的可被8整除的数，且分片数还要最少）

### IPV6的协议首部

IPV6的首部为60字节：

|            **字段名称**            | **占用位数** |                                                  **作用和描述**                                                   |                **类似 IPv4 字段**                |
| :----------------------------: | :------: | :----------------------------------------------------------------------------------------------------------: | :------------------------------------------: |
|        **版本 (Version)**        |   4 位    |                                              版本号固定为 6 (`0110`)。                                              |                      版本                      |
|    **通信量类 (Traffic Class)**    |   8 位    |                              用于标记数据报的优先级和区分服务，支持 **QoS (Quality of Service)**。                               |               区分服务 (DS Field)                |
|      **流标号 (Flow Label)**      |   20 位   |            $\text{IPv6}$ 新增字段。用于标识属于同一“流”（$\text{Flow}$）的数据报集合，路由器可以对同一流的数据报进行**快速处理**，类似于对流打标签。             |  **无直接对应** (但与 $\text{IPv4}$ 的标识用于分片的目的不同)   |
|  **有效载荷长度 (Payload Length)**   |   16 位   |                           表示 $\text{IPv6}$ 首部**之后**的字节长度，包括**扩展首部**和**上层数据**的总长度。                            | 总长度 (Total Length) **减去** $\text{IPv4}$ 首部长度 |
|    **下一个首部 (Next Header)**     |   8 位    | 用于识别 $\text{IPv6}$ 首部之后的**扩展首部类型**，或指示紧跟在 $\text{IPv6}$ 首部后面的**上层协议**（如 $\text{TCP}$ 为 6，$\text{UDP}$ 为 17）。 |                协议 (Protocol)                 |
|      **跳限制 (Hop Limit)**       |   8 位    |                       功能与 $\text{IPv4}$ 的 $\text{TTL}$ 字段完全一样。每经过一个路由器减 1，减到 0 则丢弃数据报。                       |                  生存时间 (TTL)                  |
|    **源地址 (Source Address)**    |  128 位   |                                            发送方 $\text{IPv6}$ 地址。                                             |                     源地址                      |
| **目的地址 (Destination Address)** |  128 位   |                                            接收方 $\text{IPv6}$ 地址。                                             |                     目的地址                     |

## UDP首部

UDP数据报总共8个字节

- 源端口号：2字节
- 目的端口号：2字节
- 长度：2字节
- 校验和：2字节

## TCP首部

**可靠的面向字节流的传输协议**

TCP的首部总共二十字节：

- 源端口：16位，表示发送方进程的端口号
- 目的端口：16位，表示接收方进程的端口号
- 序号：32位/4字节，0~2的32次方-1，逐渐递增，用于给传递的字节流编号，在连接建立后，序号是按字节计算的，用于实现可靠传输和乱序重排。
- 确认号：32位/4字节，表示发送方**期望收到**的对方的**下一个报文段的数据的第一个字节的序号**。例如，如果收到的报文段数据字节到 $X$ 结束，则确认号为 $X+1$。
- 数据偏移：4位，**以 4 字节（32 位）为单位**计算的 **TCP 首部长度**，该字段的最小值是 $5$（即 $5 \times 4 = 20$ 字节的标准首部），最大值是 $15$（即 $15 \times 4 = 60$ 字节，包含 40 字节的可选项）。
- 保留：6位，一段保留空间，全为0
- URG字段（urgent）：1位，为1时，紧急指针字段生效，用于存放紧急处理的信息
- ACK字段（acknowledge）：1位，为1时，表示确认号有效，否则确认号内容无效，所有建立连接后的传输都必须将 ACK 置为 $1$
- PSH字段（push）：1位，为 $1$ 时，接收方应**立刻**将报文段内的数据交给**应用层**，而不用等待整个缓冲区满。
- RST字段（rest）：1位，为 $1$ 时，表示连接出现严重错误或非法连接，请求**立即释放连接**并重新建立
- SYN字段（synchronized）：1位，为 $1$ 时表示**请求建立连接**（握手阶段使用），同时会设置一个初始序号。
- FIN字段（finish）：1位，为 $1$ 时表示**请求释放连接**（挥手阶段使用），数据发送完毕。
- 窗口：允许对方发送量，表示表示**发送方**愿意接收的**数据字节数**，用于进行**流量控制**。该值是从确认号算起。
- 检验和：1位，只有 URG 为 $1$ 时有效，指示紧急数据**末尾**相对于序号的偏移量。
- 紧急指针：16 位，与URG搭配，用于存放紧急处理的信息

## TCP的连接与释放

**三次握手与四次挥手**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251212183915.png)


TCP是双端连接，因此存在一个客户端一个服务器，服务器是被动打开，用来监听客户端是否主动打开链接

第一次握手：客户端：将SYN置为1，同时发送一个信号（seq=x，seq表示初始序号，此处为客户端的初始序号），本次报文用于建立连接，不允许携带信息

第二次握手：服务端：SYN为1，ACK为1，seq=y（服务端的初始序号），ack=x+1（ack为确认号）

第三次握手：客户端：ACK=1，seq=x+1（服务端希望的序号），ack=y+1（同时对服务端发送的序号+1）

**三次握手是为了防止客户端发送的请求报文延迟到达**

