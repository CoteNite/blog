
## 基础知识部分

[计网期末串讲](https://www.bilibili.com/video/BV1Vv411p7Sn?spm_id_from=333.788.player.switch&vd_source=9376a85d54558433ad7f11594f35ffa4)

## 概述

互联网由主机，网络，路由器组成，其中计网**核心在于路由器和网络**

### 端到端的两种方式

- 客户端-服务器模式：客户端向服务端请求服务，服务器响应服务
- p2p/端到端模式：不区分服务端和客户端，只要二者连接，就可以对等的通信
### 互联网核心部分

**路由器如何将内容转发？**

路由器要实现：

- 转发分组
- 路由器之间不断交换路由信息


### 经典的交换技术

- 电路交换：预先在通信前建立连接，一条通道直达，bit流直达终点
- 报文交换：通过报文，经过节点转发
- 分组交换：将个报文分段转发

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216124405.png)

![xxx](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216124606.png)

### 时延

时延由发送时延，传播时延，处理时延，排队时延四种

发送时延=数据帧长度/发送速率

传播时延=信道长度/电磁波在信道上传播的速度

### 利用率

当信道利用率增大时，信道的时延也会增大

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216191010.png)

上图中的D和D0都是时延，其中D0为空闲时延，进而可以得出利用率U

### 协议

网络协议，简称为协议，是为进行网络中的数据交换建立的规则，标准或规定

- 语法：网络协议的结构
- 语义：网络协议需要发出什么信息，完成什么规定
- 同步：事件实现顺序的详细说明

协议会分成多个层次以便实现更高的灵活性

### 五层协议

目前主要采用的是五层的协议

- 物理层：屏蔽传输媒体的区别（硬件上的区别）
- 数据链路层：解决三个问题————封装成帧，透明传输，差错检验
- 网络层：为分组交换的网上的不同主机提供通信服务
- 运输层：向两台主机中进程之间的通信提供服务
- 应用层：进程之间的交互实现

### 协议与层次

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216192525.png)


## 物理层

- 单工：A单向向B通信
- 半双工：AB可以互发，但不可以同时发，也不能同时收
- 全双工：通信双方可以同时发也可以同时收

### 两类传输媒体

- 导引类：电缆，光纤
- 非导引类：电磁波

### 信道复用好处

允许用户是由一个共享信道来通信，节约成本，提高利用率

### 四种信道复用技术

- 频分复用/FDM：将宽带分为多份，用户使用固定的频带进行通信
- 时分复用/TDM：将一段时间分为多个帧，每个帧用的用户都不一样，整体程周期性出现
- 统计时分复用/STDM：根据需求按需拆分时间，动态分配时隙
![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216193347.png)
- 波分复用/WDM：通过复用器和分用器实现光的频分复用
- 码分复用/CDM：不同的用户使用不同的码型，频率类似白噪声，更加隐蔽

码分复用的原理：CDM给每个用户分配的码序列各不相同且相互正交，所谓正交就是两个码的规格化内积为0，任何一个码片的向量与自己规格化内积都为1，与反码规格化内积都为-1

码分复用的好处：抗干扰能力强

码分复用的缺点：占用的带宽较大

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216194521.png)

对于规格化内积，如果结果为-1则认为发了0，结果为1则认为是1，如果为0则认为没发

### ADSL技术

对原有的电话线进行改造，使其拥有承担网络通信的能力

### HFC/光纤同轴混合网

对有限电视网进行改造

### FTTx技术

使用光纤直接接入到用户的家

### 信道

信道特指一个方向的媒体传输，与电路并不等同，一条通信电路往往包含一条发送信道和一条接受信道

### 调制的基本概念

定义：将信号源的信息进行处理加到载波上，然后就可以利于信道的传输

理由：电脑产生的为基带信号，并不适用于信道（往往含有很多的低频成分和直流成分）

调制的分类：
- 带通调制：使用载波进行调制，把基带信号的频率搬到较高的频段（使用高频载波进行调制），并转换为模拟信号以实现更好的传输，基本方法包括————调幅，调频，调相
- 基带调制：仅对基带的波形进行变化，进而使其频率发生变化，使其可以适应基带的传输

### 物理层的主要任务

**屏蔽掉不同的媒体和通信手段导致的差异，确定与传输媒体接口的一些特性**

- 机械特性：指明接口所用的接线器的形状，尺寸，引线数目等物理性状方面的特征
- 电气特性：电压相关
- 功能特性：某一电平电压的具体意义
- 过程特性：指明事件出现的顺序

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216201007.png)

## 数据链路层

数据链路层使用的两种信道：

- 点对点：AB一对一进行通信
- 广播信道：一对多进行通信，多个端公用一条信道进行通信，一个端向多个端发送信息

### 帧

点对点信道的数据链路层的协议单元

### 数据链路层的三个基本功能/问题

### 封装成帧

- 概念：在一段数据的前后分别添加帧首部和帧尾部，进而构建出一个帧
- 目的：接受端在收到物理层上交流的比特流之后，可根据首部和尾部的标记，识别帧的开始和结束
- MTU：数据链路层协议规定的所能传输的帧的数据部分长度的上限————最大传输单元MTU

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216201750.png)

如果不封装成帧的问题：

会不知道bit流的开始与结束

Q：如果不封装成帧会发生什么

A：接收端收到数据后会不知道哪些是数据，哪些是控制信息，数据在传输过程中是否会出错；接收端由于不知道数据是否结束而不知道是否要把数据传递给上层

### 透明传输

无论发送什么样的比特组合的数据，这些数据都能按照原样没有差错的通过这个数据链路层

通俗意义：假设一个帧的数据部分中出现了侦首部的片段（因为是bit流，都是0/1，很容易出现重复片段），这时应该避免将这一部分误认为帧的开始/帧首部，这个操作/实现，就称之为透明传输

- 无比特差错：接收端会受到有差错和无差错的帧，但是接收端会主动丢弃掉出现差错的帧
- 无传输差错：即可靠传输，接收端只会受到无差错，不丢弃，不重复，按序到达的帧（网络层和数据链路层无需实现（特别注意，是不要求，不是不可以））

### 差错检验

测和纠正数据在传输过程中产生的错误 (比特错误)，确保数据可靠性

利用循环冗余检验 (CRC) 等方法生成校验码，接收端通过校验码判断帧是否有错。

### PPP

**目前使用的最广泛的数据链路层协议，针对点对点通信**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216203103.png)

- FCS：用于实现CRC冗余检验
- MTU：1500字节

一些关键信息：

- PPP基于IP
- 实现了封装成帧，透明传输，差错检验（三大基本功能）
- 能在一条物理链路上支持多种网络层协议
- 能够在多种类型的链路上运行
- PPP不使用帧的编号，这是因为数据链路层不需要实现可靠传输，也就不需要帧的有序发送
- 适用于通信线路较好的情况，这是因为没有实现可靠传输，因此只能通过较好的通信线路来保证丢弃较少
- PPP不提供可靠传输

PPP解决透明传输的两种方法：
- 当PPP用在异步传输的时候会使用一种特殊的字符进行填充
- 当PPP用在同步传输链路的时候，协议会采用硬件来完成比特填充

**字符填充：**
1. 单字节的0x7E转换为两字节的0x7D，0x5E（0x7D充当转义字符）
2. 出现0x7D转化为两字节的0x7D，0x5D（用转义+0x5D充当原本的0x7D）
3. 出现了ASCII码的控制字符（即数值小于0x20的字符），**先在前面加 `0x7D`，然后将该字符与 `0x20` 进行异或（XOR）运算**。例如：出现 `0x03`（ETX），会变成 `0x7D, 0x23`（因为 $0x03 \oplus 0x20 = 0x23$

**零比特填充：**
- 发送端出现五个连续的1则立刻填充0
- 接收端对帧的比特流进行扫描，每出现五个连续的1则删除后面紧跟的一个0


### 数据链路层要实现可靠有何好处和缺点

增加了可靠性（早发现早纠正），牺牲了实时性（协议变得复杂，计算困难，传输效率变慢，这是最致命的，因为大多数情况要求数据链路层速度够快）

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216205159.png)


### 数据链路层的三大基本问题的原因/为什么要加以解决

- 封装成帧：接收端在收到物理层的比特流之后要通过帧首帧尾来确定帧的开始和结束
- 透明传输：保证无论出现什么样的比特组合都可以无差错的通过数据链路层（这里的**任何**其实一般是指帧首和帧尾使用的比特组合）
- 差错检验：使网络中的节点早点发现错误，进而减少对网络资源的浪费

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216205507.png)

### 局域网的数据链路层

通过一个站点通过**广播**的形式实现消息的传递

- 局域网的特点：网络为一个单位所有，物理范围和站点数目都有限
- 局域网的优点：具有广播功能，从一个站点可以方便的访问全网，局域网上的主机可以共享连接在局域网上的各种硬件和软件资源



Q:局域网为什么采用广播通信？

A：因为站点数目有限，物理范围有限，所以可以从一个站点方便的访问全网资源

Q:为什么广域网不用广播通信？

A：站点数目和物理范围范围太大，造成碰撞的概率过大，导致通信资源的浪费

### 以太网的两个标准

DIX Ethernet V2  和  IEEE 802.3

### 适配器

适配器 ~= 网卡

作用：
- 实现计算机内部的并行数据与外部互联网的串行数据的转换
- 缓存外部传入的数据
- 实现数据驱动
- 实现以太网协议

使用与物理层与数据链路层

### CSMA/CD协议

针对广播，用于规避广播中出现的碰撞

- 含义——CSMA/CD的翻译：载波监听多点接入/碰撞检测
- 载波监听：不管在发送前，发送中都要监听站点的状态，防止在有人发送消息的时候发送
- 多点检测：说明这是总线型网络，计算机以多点接入的形式连接在一根总线上
- 碰撞检测：即边发送边监听，碰撞就是发生了冲突，因此也成为冲突检测

### CSMA/CD与时分复用的区别

当网络负载较轻（不容易发生冲突）的时候，CSMA/CD很灵活，想谁发送就谁发送，且碰撞概率较小，如果使用时分复用，由于很多站没有信息要发送，分配的时间就浪费了，因此效率较低，当网络负担比较重的时候，由于CSMA/CD引起的碰撞较多，因而效率较低，所以推荐使用TDM

### 以太网

一种基带总线的局域网，因为曾经使用的电磁波叫以太而得名，以太网中通过广播的形式进行传输

### MAC地址

硬件地址，固化在适配器中的地址，与IP地址进行区分

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216212049.png)

### 以太网交换机的自学习功能

以太网交换机内部会维护一个交换表，会将交换机的接口与MAC地址建立联系，进而实现在广播模式下的点对点信息发送，而以太网的自学习功能就是在以太网交换机中的某个接口更换了机子（MAC地址），那么以太网交换机会自动的维护交换表，进而实现以太网交换机的即插即用

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216212827.png)

### 以太网交换机的工作原理和特点，以太网交换机和转发器的区别

工作原理：以太网交换机本身实际上就是一个网桥，工作在数据链路层，根据MAC帧的目的地址对收到的帧进行转发和过滤

特点：多接口的网桥；工作在全双工的方式；具有并行性，能同时连接多个接口，使多对主机能同时通信，相互通信的主机都是独占传输媒体，无碰撞的传输数据，用户独享宽带，增加了总容量

与转发器：转发器工作在物理层，它仅简单地转发信号，没有过滤能力

### MAC帧格式

PPP帧针对于点对点，而MAC帧针对于广播信道

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216213353.png)

主要是通过目的地址和源地址来实现广播中的针对谁通信，类型是交给IP层用的

## `网络层` / `TCP/IP中的IP层`

### 是否实现可靠传输

实现不了，只是尽最大努力的交付数据报服务

### 虚拟互联网的意义

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216220102.png)

虚拟互联网和IP地址最大的好处是屏蔽掉了数据链路层中MAC地址导致的异构差异

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251216220228.png)

### 分类IP地址/IPV4

分类的IP地址：32位，前面是网络号后面是主机号

分为五类地址，ABCDE

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217122335.png)

**点分十进制法**

对于一个32位的IP地址，可读性太差，因此我们以8位二进制为单位，将32位拆分成四个十进制数

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217123236.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217123336.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217124104.png)

- A类网中网络号除第一位以外全0的不指派，因为是本网络
- A类网中网络号除第一位以外全0的不指派，因为是本地环回地址
- 目前B类网的128.0可以指派，是最新的网络规则

### IP地址和硬件地址

硬件地址是数据链路层和物理层使用的，而IP地址是网络层以上使用的，IP地址本身是一个逻辑地址，通过软件实现

**计算机网络本身是一个层层封装的过程**

IP地址最大的意义就是去除硬件的异构性，CPU与存储器使用的就是IP地址

### IP数据报的格式

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217144428.png)

### 路由器转发分组的原理

路由器会维护一个路由表，路由器只能向其直接相连的目的主机交付信息（即下一跳地址），如果二者不直接相连，那么就需要一个中间的路由器来将两者进行连接，也就是说当前路由器的下一跳地址会是另一个路由器

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217151143.png)

确定下一跳通过收到的分组与路由表中的IP的子网掩码取AND操作来得到

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217164334.png)

### CIDR无分类域间路由选择

CIDR消除原本的ABC类以及子网的划分概念，使用网络前缀来代替老式子网掩码中的网络号和子网号，IP地址从三级编制（网络号+子网号+主机号）又回到了两级编制（网络前缀+主机号）

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217155907.png)

CIDR划分中将前缀相同的IP地址称之为一个CIDR地址块

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217160320.png)

### CIDR的好处————地址聚合

假设一个组织要4个C类网，那么ISP（Internet Service Provider）就要提供给他4个C类网，同时该组织也会在路由表上占据四行

但是使用CIDR的情况下，我们只需要分配一个/22地址块即可，此时也就只占据1行路由表

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217162015.png)

### 最长前缀匹配原则

由于CIDR下的子网划分存在大地址块包含小地址块的情况，因此在路由表找对应的时候可能会出现同时匹配两个地址的情况，此时选择与前缀最长的匹配

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217171134.png)

## 运输层

### UDP/TCP

运输层的支持协议是UDP和TCP

UDP未实现了可靠传输，TCP实现可靠传输

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217171555.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217171802.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217171815.png)

### UDP

UPD首部仅八字节，源端口，目的端口，长度，检验和各两字节

之所以这里使用端口是因为运输层是端到端的协议，运输层收到UDP数据包后要根据首部的目的端口进行复用

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217172453.png)

UDP面向报文

### TCP

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217173504.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217173828.png)

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217173941.png)

### 停止等待协议的信道利用率

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217174155.png)

TD=数据长度/数据发送速率

由公式易得，在信道发送分组的过程中，往返事件RTT和B的确认事件TA（B向A发送一个确认收到信息的消息时间，很短，有时甚至不考虑）都是浪费的事件
### 拥塞控制与流量控制

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217174755.png)

### **TCP的三次握手和四次挥手**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217184005.png)


建立一个TCP连接需要进行三次握手，必须为三次，少一次不可

1. 第一次握手：客户端会向服务端发送一个SYN报文段，该报文段中包含一个客户端随机生成的初始序列号，如seq=x，发送后客户端即可进入SYN_SEND状态，等待服务端的确认
2. 第二次握手：服务端收到客户端的SYN报文段后，如果同意建立本次连接，将会向客户端发送一个确认报文，该报文中包含两个关键的信息
	- SYN：服务端也需要向客户端同步自己的初始序列号，因此报文中也包含一个由服务端生成的随机的初始序列号，如seq=y
	- ACK：用于确认收到了客户端的请求，其确认号为客户端的初始序列号+1，即ack=x+1
	- 发送报文后，服务端进入SYN_RECV阶段
3. 第三次握手：客户端收到服务端发送的报文后会向服务端发送一个最终的确认报文，该报文包含ack=y+1，发送后客户端进入 **ESTABLISHED** 状态。服务端收到这个 ACK 报文段后，也进入 **ESTABLISHED** 状态。

由此客户端和服务端成功建立TCP连接，可以进行双向的通信

### 为什么要我三次手

TCP是一个可靠的全双工的通信信道，三次握手正是为了保证通信的安全可靠，每一次握手都有自己的意义

- 第一次握手：客户端向服务端发送SYN包，这一过程服务端确认了客户端发送能力的正常与自己接受能力的正常
- 第二次握手：服务端向客户端发送SYN+ACK包，这个过程客户端确认了服务端接受能力的正常和发送能力的正常，同时也确认了自己发送能力的正常和接受能力的正常，其中SYN的作用是告知客户端我接受到的确实是你发送的信息
- 第三次握手：客户端发送ACK包，这个过程客户端与服务端成功证明双方的正常

**为什么不能是两次握手？**

这一般也是问为什么是三次握手真正想问的，我们可以预设一个场景，客户端发送完第一握手的信息后一直没有收到服务端返回的握手信息，因此发送了第二次建立TCP的请求，这一次成功完成了三次握手，建立的TCP连接

而我们从服务端的角度来看，服务端由于网络问题，先收到的是客户端发送的第二次建立TCP的握手请求，并建立完TCP连接，此时由于网络延迟导致的客户端第一次尝试建立TCP连接的第一次握手才姗姗来迟，这时，如果只有两次握手，那么服务端收到这个SYN请求后，会误认为是客户端想要向他建立一个新的TCP连接，这个时候服务端会分配新的资源去用来建立这个TCP连接，但是这个连接本身是无效的，会白白浪费服务端的性能

但是如果有了第三次握手，服务端不会先分配资源，而是等待客户端再次发送确认的ACK包，如果一直没有接收到这个ACK包，那么服务端就会因为超时关闭这个错误的连接，进而避免了资源的浪费

在 TCP 三次握手过程中，第三次握手是可以携带数据的(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)

### 四次挥手

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251217183949.png)


如果TCP要断开连接，那么就要进行四次挥手

- 第一次挥手：当客户端决定关闭连接时，他会向服务端发送一个FIN标志的报文段，表示自己已经没有要发送的数据，该报文段包含一个序列号seq=u。发送后，客户端进入一个FIN-WAIT-1的状态
- 第二次挥手：服务端会立刻恢复一个ACK报文段，其确认号为ack=u+1，发送后，服务端进入CLOSE-WAIT状态，客户端接受到这个ACK后，进入FIN-WAIT-2状态，此时TCP连接进入半关闭状态，即客户端到服务端发送信息的通道已经关闭，但服务端仍然能向客户端发送数据
- 第三次挥手：服务端确认自己所有待发送的数据发送完毕后，也会向服务端发送一个FIN报文段，表示自己也准备关闭连接了，同样的也包含一个seq=y，发送后服务端进入LAST-ACK状态，等待客户端的最终确认
- 第四次挥手：客户端接收到服务端发送的FIN报文段后，会回复一个ACK确认报文段，确认号为ack=y+1，发送后，客户端进入TIME-WAIT状态，服务端接收到这个ACK后，立即进入CLOSED状态，完成连接的关闭，客户端则会在TIME-WAIT状态下等待2MSL（Maximum Segment Lifetime）的时间，才会进入CLOSED状态

## 习题部分

[极之心————计算机网络救急课堂](https://www.bilibili.com/video/BV1Ju4y157wh?spm_id_from=333.788.videopod.episodes&vd_source=9376a85d54558433ad7f11594f35ffa4)

## IPV4

IP地址：32位点分十进制  4 * 8 例如127.0.0.1就是4  8位二进制=255

IP地址=网络号+主机号

所以IP地址总共2的32次方个

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251210220042.png)


ABC类为单播地址，只有单播地址可以分配给主机各接口

主机号全为0的为网络地址，可做源地址，不可做目的地址

主机号全为1的为广播地址，不可做源地址，可做目的地址

A类地址：0.0.0.0~127.255.255.255 (127 = 01111111)

其中网络号为0的地址为本网络，不可指派，网络号为127的地址的为本地环回地址，不可指派

每个A类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个可指派的地址（除去全0和全1）


B类地址：128.0.0.0~191.255.255.255 

每个B类网络（网络号不同认为为一个独立的网络）可以指派2的24次方-2个地址（除去全0和全1）(B类地址网络号16位)

全球网络中有三个特殊的地址块

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

这些是专用地址，可重用

c类地址：192.0.0.0~223.255.255.255

### 总结

对于所有的网络，主机号全为0的为本网络地址，主机号全为1的为广播地址，这两个特别的地址不可指派，网络地址可做源地址不可做目的地址，广播地址可做目的地址不可做源地址

A类：网络号为8位，开头必须为0，后面32位为主机号，内含`0.0.0.0~127.255.255.255`，主机号全为0或全为1即`x.0.0.0`或`x.255.255.255`，**特别的，A类中0或127开头的不可指派**

B类：网络号为16位，开头必须为10，后面16位为主机号，内含`128.0.0.0~191.255.255.255`，主机号全为0或全为1即`x.x.0.0`或`x.x.255.255`

C类：网络号为24位，开头必须为110，后面8位为主机号，内含`192.0.0.0~223.255.255.255`，主机号全为0或全为1即`x.x.x.0`或`x.x.x.255`

三个特别的地址块，专用/可重用，可指派：

- 10.0.0.0~10.255.255.255
- 172.16.0.0~172.31.255.255
- 192.168.0.0~192.168.255.255

## 子网划分

主要是即使是一个C类地址，一个也可以分配2的8次方-2个地址，很有可能一个公司用不完，因此需要子网划分

子网划分的核心为**子网掩码**

主要干的事就是将网络号+主机号的形式转变成网络号+子网号+主机号，用连续的比特1表示网络号和子网号，用连续的比特0表示主机号

子网掩码仍然是32为二进制，但原地址主机号部分全部用1（也就是255）表示

举个例子：

IP：180.80.77.55 子网掩码：255.255.252.0

其中子网掩码前16位为255，确认为b类网络，252=（11111100） 6位1即子网号为6位

77.55=（010011（子网号）  01.00110111）

该主机所在的子网的广播地址为

180.80.010011 11.1111111  -> 180.80.79.255

## 无分类的编制方法

当我们发现使用子网的情况下仍然太大时，我们就尝试是用了无分类的编制方法

**使用的是地址掩码**

用连续的比特1表示网络号，连续的0表示主机号，其中网络号的部分被称为CIDR地址块

举个例子：

地址掩码为255.255.240.0 -> 11111111 11111111 1111 | 0000 00000000

也就是20个1和12个0 即前20位为网络号，后12位为主机号

再看回其对应的IP地址——128.14.35.7

(10000000 00001110 0010)网络号 (0011 00000111)主机号

另一种写法就是 `x.x.x.x/y` 其中的y就是网络号的位数

## 掩码的总结

掩码是对IP地址的一个解释，其连续的1的数量和0的数量使用来区分IP地址中的哪些位是网络号，哪些是主机号，子网号

因此首要的操作肯定是将掩码转换成二进制，进而根据掩码中连续为1的位数去锁定ip中的位置，这一部分就是IP的网络号（+子网号），0的部分则是主机号

得到网络号的部分，我们就可以将其固定，然后剩下的部分就可以推得到其网络地址和广播地址

## IPV6

IPV4 -> IPV6  使用了双协议栈技术+隧道技术

IPV6的地址用128位冒号16进制表示，也就是8组，每组4个

ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

由于过于难表示，因此采用`左侧0省略`+`连续0压缩`的方式表示

FE80: 0000:0000:0000:AAAA:00C2:00C2:0002

左侧0省略： 0:0:0:AAAA:0C2:0C2:02

连续0压缩： :: AAA :0C2:0C2:02  (也就是连续的0全部压缩为::)


值得一提的是连续0压缩可以用在IPV6的任何位置，但是只能使用一次，因此我们一边用在连续0最多的地方

   12AB:0000:0000:CD30:0000:0000:0000:0000
-> 12AB:0:0:CD30::

## RIP距离向量算法

现有路由器A收到如下的项目

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184238.png)

并受到C发来的路由

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251211184257.png)


第一步就是先将所有的C发来的信息更改为A视角的信息，即保留目的网络不变，所有到目的网络的距离+1（因为认为A收到C的信息，即C与A相邻，即距离为1），并将下一跳转换为C

然后与原本A的项目比较

4. 如果下一跳相同，但信息不同，则更新为A原有的
5. 如果下一跳不同，比长短，保留（A原有的）/更新（C现传的）为短的
6. 如果存在新项目，直接添加

## 协议首部

### IPV4的协议首部

总共占用20字节：

- 版本：占用4位，存协议版本，比如IPV4版本为4
- 首部长度：占用4位，表示整个首部的长度，单位是每4字节，也就是说首部长度为5，实际上表示首部有20字节
- 区分服务：占用8位
- 总长度，占用16位，首部+数据部分的总长度
- 标识：占用16位，类似计数器，产生了几个数据包，**所有分片的标识一致**
- 标志：占用3位，有三种状态，每一位代表一个状态，但其实只有两个有效的状态，即MF（More Fragment）和DF（Don't Fragment）表示数据包是否后续还有分片以及是否允许分片。针对DF位，**DF位的0和1的标准不是是否分片，而是是否可以分片**，能分片的数据就是0，1是特别的不允许分片的数据
- 片偏移：占用13位，表示该分片在原本整体中处于第几片的位置，分片的`起始位置/8`为片偏移（比如某一片的第一位为原数据的第1400位，则为1400/8=175），也就是以8字节为单位，这意味着每个分片的大小必须是8的倍数，没分片和第一片的片偏移为0
- 生存时间：占用8位，表示在传输过程中最大的存活时间
- 协议（号）：占用8位，每个协议固定的号，占用8位
- 首部检验和：占用16位，用来检验是否与误码
- 源地址：占用32位，表示发送数据包的源地址
- 目的地址：占用32位，表示接受数据包的目的地址

MTU：数据报的最大长度（包含首部）

当MTU最大化利用的情况下片偏移非整数时，则使用可以被整除的最大部分（即每个分片为最大的可被8整除的数，且分片数还要最少）

### IPV6的协议首部

IPV6的首部为60字节：

|            **字段名称**            | **占用位数** |                                                  **作用和描述**                                                   |                **类似 IPv4 字段**                |
| :----------------------------: | :------: | :----------------------------------------------------------------------------------------------------------: | :------------------------------------------: |
|        **版本 (Version)**        |   4 位    |                                              版本号固定为 6 (`0110`)。                                              |                      版本                      |
|    **通信量类 (Traffic Class)**    |   8 位    |                              用于标记数据报的优先级和区分服务，支持 **QoS (Quality of Service)**。                               |               区分服务 (DS Field)                |
|      **流标号 (Flow Label)**      |   20 位   |            $\text{IPv6}$ 新增字段。用于标识属于同一“流”（$\text{Flow}$）的数据报集合，路由器可以对同一流的数据报进行**快速处理**，类似于对流打标签。             |  **无直接对应** (但与 $\text{IPv4}$ 的标识用于分片的目的不同)   |
|  **有效载荷长度 (Payload Length)**   |   16 位   |                           表示 $\text{IPv6}$ 首部**之后**的字节长度，包括**扩展首部**和**上层数据**的总长度。                            | 总长度 (Total Length) **减去** $\text{IPv4}$ 首部长度 |
|    **下一个首部 (Next Header)**     |   8 位    | 用于识别 $\text{IPv6}$ 首部之后的**扩展首部类型**，或指示紧跟在 $\text{IPv6}$ 首部后面的**上层协议**（如 $\text{TCP}$ 为 6，$\text{UDP}$ 为 17）。 |                协议 (Protocol)                 |
|      **跳限制 (Hop Limit)**       |   8 位    |                       功能与 $\text{IPv4}$ 的 $\text{TTL}$ 字段完全一样。每经过一个路由器减 1，减到 0 则丢弃数据报。                       |                  生存时间 (TTL)                  |
|    **源地址 (Source Address)**    |  128 位   |                                            发送方 $\text{IPv6}$ 地址。                                             |                     源地址                      |
| **目的地址 (Destination Address)** |  128 位   |                                            接收方 $\text{IPv6}$ 地址。                                             |                     目的地址                     |

## UDP首部

UDP数据报总共8个字节

- 源端口号：2字节
- 目的端口号：2字节
- 长度：2字节
- 校验和：2字节

## TCP首部

**可靠的面向字节流的传输协议**

TCP的首部总共二十字节：

- 源端口：16位，表示发送方进程的端口号
- 目的端口：16位，表示接收方进程的端口号
- 序号：32位/4字节，0~2的32次方-1，逐渐递增，用于给传递的字节流编号，在连接建立后，序号是按字节计算的，用于实现可靠传输和乱序重排。
- 确认号：32位/4字节，表示发送方**期望收到**的对方的**下一个报文段的数据的第一个字节的序号**。例如，如果收到的报文段数据字节到 $X$ 结束，则确认号为 $X+1$。
- 数据偏移：4位，**以 4 字节（32 位）为单位**计算的 **TCP 首部长度**，该字段的最小值是 $5$（即 $5 \times 4 = 20$ 字节的标准首部），最大值是 $15$（即 $15 \times 4 = 60$ 字节，包含 40 字节的可选项）。
- 保留：6位，一段保留空间，全为0
- URG字段（urgent）：1位，为1时，紧急指针字段生效，用于存放紧急处理的信息
- ACK字段（acknowledge）：1位，为1时，表示确认号有效，否则确认号内容无效，所有建立连接后的传输都必须将 ACK 置为 $1$
- PSH字段（push）：1位，为 $1$ 时，接收方应**立刻**将报文段内的数据交给**应用层**，而不用等待整个缓冲区满。
- RST字段（rest）：1位，为 $1$ 时，表示连接出现严重错误或非法连接，请求**立即释放连接**并重新建立
- SYN字段（synchronized）：1位，为 $1$ 时表示**请求建立连接**（握手阶段使用），同时会设置一个初始序号。
- FIN字段（finish）：1位，为 $1$ 时表示**请求释放连接**（挥手阶段使用），数据发送完毕。
- 窗口：允许对方发送量，表示表示**发送方**愿意接收的**数据字节数**，用于进行**流量控制**。该值是从确认号算起。
- 检验和：1位，只有 URG 为 $1$ 时有效，指示紧急数据**末尾**相对于序号的偏移量。
- 紧急指针：16 位，与URG搭配，用于存放紧急处理的信息

## TCP的连接与释放

**三次握手与四次挥手**

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251212183915.png)


TCP是双端连接，因此存在一个客户端一个服务器，服务器是被动打开，用来监听客户端是否主动打开链接

第一次握手：客户端：将SYN置为1，同时发送一个信号（seq=x，seq表示初始序号，此处为客户端的初始序号），本次报文用于建立连接，不允许携带信息

第二次握手：服务端：SYN为1，ACK为1，seq=y（服务端的初始序号），ack=x+1（ack为确认号）

第三次握手：客户端：ACK=1，seq=x+1（服务端希望的序号），ack=y+1（同时对服务端发送的序号+1）

**三次握手是为了防止客户端发送的请求报文延迟到达**

## 简答题

### 物理层接口的几个特性，分别是什么？

分为四个特性

1. **物理特性**：**接线器**的尺寸，形状，固定和锁定装置等
2. **电气特性**：**电缆**在哪条线路上出现的电压是什么范围的
3. **功能特性**：**某条线上的某个电平**表示什么含义
4. **规程特性**：**不同功能的各种事件**出现的顺序

### 网络协议的三个要素是什么？打开网页会用到哪些协议

三个要素是————**语义，语法，同步**

- 语义：何时发出何种信息（ACK，TTL等各种东西的约束）
- 语法：数据与控制信息的**结构或格式**（信息结构）
- 同步：时间实现的顺序（三次握手）

常见的协议：DNS，HTTP，FTP，ARP

### 五层协议的PDU（数据单元）

- 物理层：bit
- 数据链路层：帧
- 传输层：分组/数据包
- 网络层：报文
- 应用层：报文

### 分组交换的步骤

1. 将待传的长报文分割，分组交换在线路上采用动态复用技术传送按一定长度分割为许多的小段
2. 加上首部形成分组
3. 各个分组的每个节点按存储——转发的模式独立传输：每个分组表示后，在一条物理线路上采用动态复用的技术，同时传递多个数据分组。把来自用户发送端的数据暂存在交换机的存储器里，接着在内网转发
4. 到达接收端后，再去掉分组头部，将各数据字段按顺序重新装配为完整的报文，分组交换比电路交换的电路利用率搞，比保温交换的传输延时小，交互性好

### 说明IP地址和硬件地址的区别，为什么要使用两种地址

IP地址为虚拟地址，是给每个连接在因特网上的主机或路由器分配的一个全世界唯一的32位标识，进而将整个因特网看成一个单一的抽象的网络，在网络层及以上使用

而在实际的网络链路上传输数据帧的时候，最终还是要使用到硬件地址

MAC地址在一定程度上与硬件一致，基于物理，能够标识具体的链路通信对象，IP地址基于逻辑域的划分，不受硬件限制，用于数据链路层以下使用


