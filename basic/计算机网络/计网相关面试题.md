# 计网相关面试题

## 网络模型

目前常用的网络模型是四层模型，也就是Tcp/Ip网络模型

四层分别为
1. **应用层**：支持Http，SMTP等最终用户进程
2. **传输层**：处理主机到主机的通讯（TCP,UDP）
3. **网络层**：寻址的路由数据包（IP协议）
4. **链路层**：通过网络的物理电线，电缆或无线通信的移动比特

**常见的应用层协议**：Http，Https，CDN，DNS，FTP这些都属于应用层的协议

## Http报文是个什么

应用层会承载一定的信息，这些信息就是报文，简单来说就是传输和返回的数据，

这样说可能听起来很迷，看有什么就知道了

- **请求报文**：
	- **请求行**：包含本次请求的方法（POST/GET...），请求的目标（URL/URI）与Http协议的版本
	- **请求头**：包含本次请求的附加信息，比如**HOST/UserAgent/Content Type等**
	- **空行**：头和体的分割
	- **请求体**：请求中的其他附带数据
- **响应报文**：
	- **状态行**：包含Http协议版本，状态码，状态信息等
	- **响应头部**：关于相应的附带信息
	- **空行**：头和体的分割
	- **相应体**：相应中的其他附带数据

## Http的常用状态码

- 1xx：提示信息，表示有后续操作，实际使用较少
- 2xx：成功处理，200/204/206
- 3xx：重定向
- 4xx：客户端发送的报文有问题
- 5xx：服务器返回的数据有问题

常见的有200（Success），404（找不到页面），405（请求的方法类型不支持），500（服务器内部出错）

## GET和POST的区别究竟在哪

虽然CRUD各自都有一个对应的请求类型，但是大多项目都只用了两种——POST和GET，一个拿一个推

GET请求的参数一般写在URL中，而URL只支持ASCII码，请浏览器本身会对URL的长度进行限制（HTTP协议对其没有限制）

POST请求的参数则一般写在请求体中，格式任意

一般会说GET是安全的，因为根据RPC协议中GET只负责请求资源，请求这个操作是不会对服务端产生影响的，因此是安全且幂等的，反之，POST是不安全的

## HTTP默认的端口是哪个

Http是80（Nginx用的那个），Https是443

## Http1.1的拆包

Http/1.1中，请求的拆包基于“Content-Length”字段进行，这个字段表示了本次**请求**的长度，服务器可以根据他来正确的接受和解析相应长度的数据，基于这种方式可以保证服务器正确的接受到完整的数据，避免了请求的丢失问题

## Http的断点重传是什么

断点重传是Http的一个特性，使Http支持数据传输中断后继续传输数据

一个简单的流程：

1. 服务端发送一个Accept-Range：bytes来告诉客户端这个请求支持Range
2. 客户端断开重连后需要在请求头中声明本次重传的位置Range：bytes=xxx
3. 服务端接收到数据后重指定位置开始发送数据，并在相应头中添加：Content-Range：bytes断点位置/全部，Content-Length：剩余长度，此时的状态码应该是206


## Http为什么是不安全的

Http本身是明文传输的数据，因此会存在这些风险

- **窃听风险**：比如通信链路上可以获取通信内容
- **篡改风险**：强制植入广告
- **冒充风险**：会被冒充

## HTTP/TCP三次握手是什么

**握握手，握握双手**

握手本质上是为了建立可靠的连接，或者说只有握了手连接才是可靠的

Http底层基于TCP实现，TCP只有进行了三次握手才能建立可靠的连接

最初客户端和服务端都是Close的状态，然后服务端会转变为Listen状态，监听某个特定的端口

### 第一次握手（SYN）

客户端发送一个 SYN (同步序列号) 包到服务器，请求建立连接。

**这一过程属于客户端请求服务端连接**
### 第二次握手（SYN-ACK）

服务端接受到SYN包后，如果同意连接，就会发送一个SYN-ACK包给客户端，表示自己已经收到了客户端的连接请求并且同意连接

**这一过程属于服务端允许客户端请求**
### 第三次握手 (ACK)

客户端收到了SYN-ACL包后再发送一个ACK包给服务器，表示我已经知道你准备好了

**这一过程属于客户端知道服务端已经允许请求，确认连接**


## HTTPS的四次握手

在TCP建立好连接后，Http传输开始前，还需要一个TLS/SSL握手的过程，这个过程用于建立一个安全的加密通道，一般说的Https四次握手就是这个

### 第一次握手

客户端向服务器发送以下信息

1. 客户端支持的TLS版本
2. 客户端生成的随机数，用于生成会话密钥
3. 客户端支持的加密套件列表

### 第二次握手

服务端收到客户端的信息后发出相应

1. 确认TLS协议版本是否被浏览器支持，若不支持关闭加密通道
2. 服务器生产的随机数，也用于生产会话秘钥
3. 确认密码套件
4. 服务器的数字证书

### 第三次握手

客户端会通过浏览器或操作系统中的CA公钥来确认服务器的数字证书是否真实

若没问题，客户端会从数字证书取出服务器的公钥，然后使用它的加密报文发送以下信息

1. 一个随机数，会被服务器公钥加密
2. 加密通信算法改变通知，表示随后的信息都将会用会话密钥通信
3. 客户端握手结束通知

### 第四次握手

服务端收到客户端的数据后计算本次通话的会话密钥，发送以下信息给客户端

1. 加密算法的变更通知，表示后续会使用会话密钥进行加密
2. 服务端握手结束通知


## token，cookie和session的区别

- session存储于服务器中，具有唯一的sessionId，sessionId存放于Cookie中，服务端通过解析Cookie中的SessionId来确定Session
- Cookie类似一个令牌，会在每次请求的时候被浏览器自动添加

