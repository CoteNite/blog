# 缓存设计

虽然之前的文章有提到过Redis，但没有很系统的对缓存讲过，这边以缓存为重点来讲一下Redis

## 为什么用缓存

很多的小伙伴肯定会在自己的项目中写：**用Redis实现了缓存** 

这个时候面试官很自然的就会问：你为啥要实现缓存，不实现行不行，那实现了有啥好处坏处

这里就着重说一下这个问题。

缓存的作用通常就两个：**高并发和高性能**

### 高性能

由于MySQL自身的问题，我们的数据量达到十万条甚至百万条的时候就会导致性能降低（响应速度>200ms），所以我们必须得找另一个解决方案，这里就是使用的缓存，通过缓存的方式，我们可以针对某些热点数据做单独处理，进而让查询的性能提升到200ms以内

### 高并发

根据测试MySQL由于自身的架构问题，其对高并发的适配较差，基本2000QPS就会报警，而对于一个用户量大的系统，高峰期来个1w的QPS直接给MySQL干成sb了，所以我们必须得作一层预防处理，这里就是使用的Redis

（其实你也可以换一个数据库，这里推荐一下TiDB（据说B站用的就是这个数据库））

## Redis的线程模型是什么，Redis为什么单线程却能支持高并发

这应该是Redis原理最简单的问题了

### Redis线程模型

**这里得划分一下，Redis 6.0之前Redis确实是单线程的，但6.0以后，Redis引入了多线程，这里先说一下6.0之前的状况**

Redis内部使用文件事件处理器`file event handler`，这玩意是单线程的，因此我们才会说Redis是单线程模型，它采用IO多路复用的机制（其实也就是NIO）监听了多个Socket，将产生事件的socket压入内存队列中，然后事件分派器根据socket上的事件类型来选择相应的事件处理器进行处理

（关于NIO我也在一篇文章中做了简单的介绍，如果对这一块有点懵的话可以去看一下）

### 一次完整的流程

搜先Redis客户端初始化的时候，会先将Server Socket中的 AE_READABLE 事件与连接应答处的处理器关联

客户端socket向Redis进程的Server socket发起连接请求，此时的Server Socket会产生一个AE_READABLE事件，NIO程序监听到Server Socket产生的事件后，将该Socket压入队列中，文件事件分派器从队列中获取socket，交给连接应答处理器，连接应答处理器会创建一个新的能与客户端通信的Socket（后文称为Connected Socket，这是我自己瞎起的名字，没啥意义），并将该Socket的AE_READABLE事件与命令请求器关联。

> 这里区分一下两个Socket
> 
> 第一个由客户端发出的Socket用于与Server Socket来确定连接，ServerSocket只负责监听，绑定，其作用是在一个特定的端口上监听来自任何客户端的请求，是一个被动的等待者
> 
> 而第二个Socket用于在监听Socket成功接收到一个连接后，专门与这个特定的客户端来进行通信的Socket，用来接收后续的命令等


这时假设客户端发起一个Redis命令，那么Connected Socket就会产生一个AE_READABLE事件，IO多路复用程序将Connected Socket压入队列，此时事件分派器会从队列中获取Connected Socket产生的AE_READABLE事件，然后交给命令处理器来处理。处理完成操作后，事件处理器会让回复处理器建立一个对Connected Socket的AE_WRITABLE事件的关联，等待AE_WRITABLE事件进入队列

当客户端准备好接受数据时，Connected Socket就会创建一个AE_WRITABLE事件，然后压入队列当中，当事件分派器找到了关联的命令回复处理器后，就会由命令回复处理器来将本词操作地方结果回复出去，然后接触事件回复处理器对该Connected Socket的AE_WRITABLE事件的关注

### 为啥单线程还能高效率

Redis的高效是大家有目共睹的，那为啥Redis单线程还能这么高效呢？

- 纯内存操作，就是快
- NIO的强大
- C语言的强大
- 单线程避免了上下文切换的耗时，也预防了多线程的竞争问题

### Redis引入多线程

**在Redis 6.0之后，Redis引入了多线程，使得Redis可以使用多线程模型**

这主要是因为Redis发现网络开销也是单线程太慢了，读写网络的Read/Write占用了CPU的大部分时间，因此有必要重做Redis的网络读写部分，使其成为多线程的状态

这里需要特别注意的是，Redis仅仅在网络数据的读写和协议解析层面做了多线程处理，执行命令仍然还是单线程的


## Redis的数据类型

这也是一个相对简单的问题，就是看你对Redis孰不熟练

Redis 主要有以下几种数据类型：

- Strings
- Hashes
- Lists
- Sets
- Sorted Sets

> Redis 除了这 5 种数据类型之外，还有 Bitmaps、HyperLogLogs、Streams 等。你也可以通过安装插件的方式引入Bloom Filter，Roaring Birmap等特别的数据结构

### Strings

这就是最简单的KV数据库的形式

### Hashes

V变成了HashMap

### Lists

这玩意是个有序列表，支持随机位置的插入，同时对头尾的插入和取出也做了专门的处理，因此这玩意理论上也可以实现队列和栈，常说的基于Redis实现消息队列也是说的利用这个数据结构

### Sets

无序集合，自动取重，这玩意最大的作用是用来取出重复的数据

### Sorted Sets

有序集合，其顺序取决于一个Score，需要用户在set的时候传入

## Redis的过期策略

从这里往后就是稍微偏难一点的问题了，首先是Redis的过期相关的问题，我们都知道可以向Redis中加入一个ExpireTime来设定一对KV的过期时间，但是在生产环境的 Redis 经常会丢掉一些数据，写进去了，过一会儿可能就没了。这都是Redis过期策略的问题

Redis采用的过期策略为 **定期删除+惰性删除**

### 定期删除

Redis的数据并不是真的时间到了就会删除，而是会有一个规定的时间（比如100ms），每隔这么一段时间Redis就会检测一次，然后将已经过期的数据删除掉

但是由于Redis中可能存放很多的数据（比如10w+），这个时候如果每100ms就对10w个数据进行检测，那算是彻底烂完了，CPU直接干废了，**因此Redis的定期删除并非每隔一段时间就对所有的数据检查一次，而是对部分数据进行检查**

但这样又会引入一个问题——**那如果有个Key倒霉，过期了一直没有被删掉怎么办**

这就引入了惰性删除

### 惰性删除

Redis的惰性删除就是说，当你在获取一个Key的时候，Redis会先去检查一下这个Key有没有过期，如果过期了，那么Redis就会主动的删除这个Key，然后不返回任何数据

但是这又引入一个新的问题——**如果一个Key更倒霉，不光一直没有被定期删除掉，还一直没被人用过，那怎么办？**

这里就要引入内存淘汰的机制

### Redis的内存淘汰机制

Redis的内存淘汰机制有很多，这里就放出相对常用的

- allkeys-lru：当内存不够写入新数据时，引出最近最少使用的Key
- volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。
- volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。

**为什么会选择allkeys-lru为默认的策略**

主要是相对另外两个，
