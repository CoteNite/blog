# 缓存设计

虽然之前的文章有提到过Redis，但没有很系统的对缓存讲过，这边以缓存为重点来讲一下Redis

## 为什么用缓存

很多的小伙伴肯定会在自己的项目中写：**用Redis实现了缓存** 

这个时候面试官很自然的就会问：你为啥要实现缓存，不实现行不行，那实现了有啥好处坏处

这里就着重说一下这个问题。

缓存的作用通常就两个：**高并发和高性能**

### 高性能

由于MySQL自身的问题，我们的数据量达到十万条甚至百万条的时候就会导致性能降低（响应速度>200ms），所以我们必须得找另一个解决方案，这里就是使用的缓存，通过缓存的方式，我们可以针对某些热点数据做单独处理，进而让查询的性能提升到200ms以内

### 高并发

根据测试MySQL由于自身的架构问题，其对高并发的适配较差，基本2000QPS就会报警，而对于一个用户量大的系统，高峰期来个1w的QPS直接给MySQL干成sb了，所以我们必须得作一层预防处理，这里就是使用的Redis

（其实你也可以换一个数据库，这里推荐一下TiDB（据说B站用的就是这个数据库））

## Redis的线程模型是什么，Redis为什么单线程却能支持高并发

这应该是Redis原理最简单的问题了

### Redis线程模型

**这里得划分一下，Redis 6.0之前Redis确实是单线程的，但6.0以后，Redis引入了多线程，这里先说一下6.0之前的状况**

Redis内部使用文件事件处理器`file event handler`，这玩意是单线程的，因此我们才会说Redis是单线程模型，它采用IO多路复用的机制（其实也就是NIO）监听了多个Socket，将产生事件的socket压入内存队列中，然后事件分派器根据socket上的事件类型来选择相应的事件处理器进行处理

（关于NIO我也在一篇文章中做了简单的介绍，如果对这一块有点懵的话可以去看一下）

### 一次完整的流程

搜先Redis客户端初始化的时候，会先将Server Socket中的 AE_READABLE 事件与连接应答处的处理器关联

客户端socket像Redis进程的Server socket发起连接请求，此时的Server Socketh

### 为啥单线程还能高效率

Redis的高效是大家有目共睹的，那为啥Redis单线程还能这么高效呢？

- 纯内存操作，就是快
- NIO的强大
- C语言的强大
- 单线程避免了上下文切换的耗时，也预防了多线程的竞争问题

### Redis引入多线程

**在Redis 6.0之后，Redis引入了多线程，使得Redis可以使用多线程模型**

这主要是因为Redis发现网络开销也是单线程太慢了，读写网络的Read/Write占用了CPU的大部分时间，因此有必要重做Redis的网络读写部分，使其成为多线程的状态
