# 消息队列

## 技术选型

首先我们必须要知道的是，市面上常见的MQ就四个——**ActiveMQ，RabbitMQ，RocketMQ，Kafka**

其中由于ActiveMQ因为没怎么经受过大规模吞吐量，导致现在很少使用了，而Kafka由于自身的一些设计特点，导致他更加适合大数据领域的实时计算和日志采集

因此我们的项目一般情况下只会设计到RabbitMQ和RocketMQ这两个

其中RocketMQ是阿里开源，后捐献给Apache基金会，社区相对不活跃，但是由于是Java开发，因此可以相对较好的将代码拉下来学习，所以如果公司的技术实力够的话还是很推荐RocketMQ的（而且根据我对阿里开源的观察，阿里系的开源软件一般都是针对秒杀场景的）

而RabbitMQ基于erlang语言开发，这个语言在设计当初就是为了接受分布式而做的语言，因此其并发量也不必多说，且社区一直活跃，所以如果对公司的技术水平信息不够，或许RabbitMQ才是一个更好的选择

一些具体的区别（来源于Doocs）

| 特性              | ActiveMQ                   | RabbitMQ                      | RocketMQ                                                               | Kafka                                                                                |
| --------------- | -------------------------- | ----------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| 单机吞吐量           | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ                    | 10 万级，支撑高吞吐                                                            | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景                                               |
| topic 数量对吞吐量的影响 |                            |                               | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性             | ms 级                       | 微秒级，这是 RabbitMQ 的一大特点，延迟最低    | ms 级                                                                   | 延迟在 ms 级以内                                                                           |
| 可用性             | 高，基于主从架构实现高可用              | 同 ActiveMQ                    | 非常高，分布式架构                                                              | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用                                               |
| 消息可靠性           | 有较低的概率丢失数据                 | 基本不丢                          | 经过参数优化配置，可以做到 0 丢失                                                     | 同 RocketMQ                                                                           |
| 功能支持            | MQ 领域的功能极其完备               | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好                                                  | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用                                         |

## 为什么要用消息队列

很多小伙伴在写分布式项目的时候就想到要放消息队列进技术栈里，但是没有考虑过为什么，这是很不合理的，一下子就能被面试官看出是市面上抄的项目，

**那为什么要用消息队列呢？**

消息队列的作用常见的就三个——**解耦，削峰，异步**

### 解耦

**场景：**

   用户删除自己博客上的文章，那么首先会经过我们的博客模块，然后去删除数据库中的数据，接着就可以理解返回给用户了，但这样还没完，因为我们的博客文章是在长文本模块控制的Cassandra中，博客图片则在oss模块下的minio（或则其他的什么oss系统）中，则时我们就可以引入消息队列，让消息队列在博客模块完成自己的操作后就发布出一个消息，然后就不用管了，其他的模块自己监听消息，若消息来到就执行自己的操作即可

这里的一个关键点在于 **不关心/约定大于配置** ，即消息的发出者和接受者只需要约定好相同的topic和consumer即可，后面的都不用关心了，将与其他模块的关联降到最小

### 异步


