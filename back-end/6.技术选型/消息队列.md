# 消息队列

## 技术选型

首先我们必须要知道的是，市面上常见的MQ就四个——**ActiveMQ，RabbitMQ，RocketMQ，Kafka**

其中由于ActiveMQ因为没怎么经受过大规模吞吐量，导致现在很少使用了，而Kafka由于自身的一些设计特点，导致他更加适合大数据领域的实时计算和日志采集

因此我们的项目一般情况下只会设计到RabbitMQ和RocketMQ这两个

其中RocketMQ是阿里开源，后捐献给Apache基金会，社区相对不活跃，但是由于是Java开发，因此可以相对较好的将代码拉下来学习，所以如果公司的技术实力够的话还是很推荐RocketMQ的（而且根据我对阿里开源的观察，阿里系的开源软件一般都是针对秒杀场景的）

而RabbitMQ基于erlang语言开发，这个语言在设计当初就是为了接受分布式而做的语言，因此其并发量也不必多说，且社区一直活跃，所以如果对公司的技术水平信息不够，或许RabbitMQ才是一个更好的选择

一些具体的区别（来源于Doocs）

| 特性              | ActiveMQ                   | RabbitMQ                      | RocketMQ                                                               | Kafka                                                                                |
| --------------- | -------------------------- | ----------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| 单机吞吐量           | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ                    | 10 万级，支撑高吞吐                                                            | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景                                               |
| topic 数量对吞吐量的影响 |                            |                               | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性             | ms 级                       | 微秒级，这是 RabbitMQ 的一大特点，延迟最低    | ms 级                                                                   | 延迟在 ms 级以内                                                                           |
| 可用性             | 高，基于主从架构实现高可用              | 同 ActiveMQ                    | 非常高，分布式架构                                                              | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用                                               |
| 消息可靠性           | 有较低的概率丢失数据                 | 基本不丢                          | 经过参数优化配置，可以做到 0 丢失                                                     | 同 RocketMQ                                                                           |
| 功能支持            | MQ 领域的功能极其完备               | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好                                                  | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用                                         |

## 为什么要用消息队列

很多小伙伴在写分布式项目的时候就想到要放消息队列进技术栈里，但是没有考虑过为什么，这是很不合理的，一下子就能被面试官看出是市面上抄的项目，

**那为什么要用消息队列呢？**

消息队列的作用常见的就三个——**解耦，削峰，异步**

### 解耦

**场景：**

   用户删除自己博客上的文章，那么首先会经过我们的博客模块，然后去删除数据库中的数据，接着就可以理解返回给用户了，但这样还没完，因为我们的博客文章是在长文本模块控制的Cassandra中，博客图片则在oss模块下的minio（或则其他的什么oss系统）中，则时我们就可以引入消息队列，让消息队列在博客模块完成自己的操作后就发布出一个消息，然后就不用管了，其他的模块自己监听消息，若消息来到就执行自己的操作即可

这里的一个关键点在于 **不关心/约定大于配置** ，即消息的发出者和接受者只需要约定好相同的topic和consumer即可，后面的都不用关心了，将与其他模块的关联降到最小

### 异步

这里的异步和解耦在过程上很像，重点在于关注的地方不同

解耦关注的是如何在A模块不感知到BCD模块的情况下就能完成整套的业务流程，而异步关注的重点是A模块在无需要求BCD返回结果的情况下如何可以快速的调用BCD模块来完成业务

所以有时候你会看到一些项目中一个模块内有一整个配对的消息发出者和接受者，这有可能就是在实现异步

**那么什么场景需要异步呢？**

其实只要你想到多线程实现异步的时候基本都可以用消息队列来实现异步

比如博客系统中，用户想要修改自己的文章，由于我们的论坛系统随着用户的人数上升，这个操作的耗时可能也会增加，因此这个过程可以直接丢给消息队列让他去发布消息异步修改，而接口立即返回结果给用户

那么这里就很自然的引出第二个问题

**消息队列和多线程在异步上有什么区别？**

- **消息队列：**
  - **可靠性高(优点)：** 消息队列引入持久化机制，且自带重试功能
  - **复杂度高(缺点)：** 消息队列因为引入了一个新的中间件，复杂度显著增加（缺点）
  - **可用性降低(缺点)：** 消息队列相当于多引入了一个中间件，他挂了就联不通了，可用性自然下降了

- **多线程：**
  - **复杂度低：** 由于没有引入多余中间件，因此复杂度较低
  - **资源开销大：** 由于线程的销毁，创建，切换都会占用系统资源，因此过多的线程会导致性能的下降

### 削峰

有的系统在某个时间的请求量会大幅上升（比如秒杀场景），这时如果没有一个合理的预防方案就很容易将我们的系统打崩

而消息队列由于可以储存部分消息，并且可以让消息以一定的流速流出，因此常常被用作削峰


## 如何保证消息队列的高可用

首先我们得先定义什么叫可用性

**可用性：系统服务不中断运行时间占实际运行时间的比例**

业界有时后会用几个9来说一个系统的可用性有多高

比如四个9就是99.99%，代表着全年不可用时间在52.6分钟以内,表示该系统在连续运行1年时间里最多可能的业务中断时间是52.6分钟（一年总时间的0.01%的时长）

**而这里提到MQ的高可用，其实就是说如何保证MQ不会轻易挂掉**

### RocketMQ

RocketMQ在架构上分为四个部分
- Producer：消息生产者
- Consumer：消息消费者
- CommitQueue：逻辑队列，内部仅存储一个物理地址，用来指向一个CommitLog，每一个Topic下的每个MessageQueue都一个对应的ConsumerQueue
- CommitLog：提交日志，也就是真实的存储文件，被发送的消息本身
- BrokerServer：消息存储，投递，查询以及服务的高可用，可以姐搜Producer发布过来的消息，同时也可以将CommitLog持久化
- NameServer：Topic的注册中心，支持对Broker的动态注册与发现

其中NameServer是无状态的，也就是说只要使用集群部署，有一个NameServer可用，那么整体就是可用的，多部署几个NameServer就好，Broker，Consumer和Producer会自动的向对用的NameServer上去注册和连接

> **无状态：** 指各节点之间平等，不存在主从关系

由于NameServer的无状态性，因此RockerMQ的可用性关键就放在了Broker上

一般我们会推荐**多主多从**的方式进行部署 （du）


