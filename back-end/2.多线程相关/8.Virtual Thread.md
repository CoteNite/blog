# Virtual Thread

[JEP444:关于引入虚拟线程的设想](https://openjdk.org/jeps/444)
[Kotlin协程之父对于Java虚拟线程的看法](https://www.jvm-weekly.com/p/what-does-roman-elizarov-coroutines?sd=pf)
[Java虚拟线程与Kotlin协程相互合作在SpringBoot上实践的可能](https://www.youtube.com/watch?v=szl3eWA0VRw)

Go与Kotlin的协程已经发布很长一段时间了，Java虚拟线程却在JDK21中才到来，今天我们就来聊一下协程的事情

（由于我只熟悉Java和Kotlin语言，因此本文的讨论主要是基于Java的VirtualThread和Kotlin的coroutine）

## 协程是什么？为什么是协程？

我始终认为了解一个东西必须了他为什么存在，又为为什么而来。

首先是存在了许多年的Java线程（Thread），他本质上是与操作系统的系统的线程是一一对应的，也就是一个操作系统级别的线程对应一个代码中的Thread。

这样确实解决了高并发的需求——”Thread-Per-Request“，但是对应的就会出现一个新的问题——开销太大

由于系统级别的线程产生的开销过大，因此我们很难做到创建1w个线程去应对1w个请求这种情况，因此我们迫切的需要一种轻量级的线程

也是为了解决这个需求，协程出现了

协程的协指的是协作，代表多个协程之间是相互协作的关系，多个协程基于多个或一个线程，然后大家主动的使用或者让出这个线程给其他的协程使用。

协程本事与操作系统无关，是由代码进行实现，由于与线程不再是一一对应的关系（往往协程数远大于其基于的线程数），因此开销被大范围的降低了
## Java的VirtualThread

Java的VirtualThread最早于JDK19登场，并在JDK21进入长期维护的版本，于JDK25针对开发过程的不适进行完善（虽然可能没有完善所有问题）

由于Java自身较大的历史包袱，VirtualThread选择了从底层的Thread接口进行实现，并且实现了使用类似同步的方式来进行调用



