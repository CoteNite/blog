# Spring——IOC&AOP

## IOC

### 简洁

IOC的全称是Inversion of Control，即控制反转，所谓的反转指的是用户将创建实例的过程交给框架（的IOC容器）完成，框架将创建好的实例给到用户。（所以所谓的“正转”其实就是老式的手动创建框架提供的类实例的方式）

而这一过程的实现使用了DI（Dependency Injection/依赖注入）

其中DI其实应该算是IOC的一种实现方式，即通过将组件需要的依赖自动化的注入到组件中进而完成IOC的整个过程

由于我们将实例的创建交给了框架完成，所以整个实例的生命周期也是由框架托管了

### IOC的设计思路

**设计一个IOC应该考虑到哪些的**？

这其实还是个大象冰箱的问题

1. 如何知道哪些类应该作为Bean？
2. 如何创建Bean？
3. 如何将Bean注入到需要他的位置/如何为组件注入他需要的Bean？/如何管理这些Bean？
4. 如何在合适的时候销毁Bean？

看似简单，其实每一步都有很多值得延申的地方

### IOC的核心组件

Spring中的Bean使用了经典的工厂模式进行注册与创建

其中在Spring的配置文件中，每一个 < bean > 节点元素实际上都会通过一个BeanDefinition对象标识描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法

IOC容器的接口类是ApplicationContext，继承了BeanFactory对Bean规范，负责了Bean的管理，同时还支持了更加广泛的功能（对不同配置方式的Bean进行加载，支持国际化，支持应用事件等）

### 容器的加载

Spring IOC对Bean定义资源的载入是从refresh方法开始的，refresh的逻辑是：在创建IOC容器前，如果已经有容器存在，则销毁和关闭该容器，这一过程保证了refresh后的IOC容器是新建立起来的，refresh的功能正如refresh的名字一样——刷新

接着，创建好的IOC容器会使用loadBeanDefinition来载入bean定义，这一过程会使用ResourceLoader来完成资源文件（也就是定义了Bean信息的文件）的定位

然后Spring会使用BeanDefinitionReader来完成定义信息（这些内容被映射为BeanDefinition对象）的解析与Bean的注册

最后，IOC容器再得到BeanDefinition后，需要将器注册于IOC容器中，这一过程由BeanDefinitionRegistry 接口来实现，注册的过程就是再IOC容器内部去维护一个ConcurrentHashMap来保存获得的BeanDefinition信息，这个ConcurrentHashMap是IOC容器持有Bean信息的场所，以后对 bean 的操作都是围绕这个ConcurrentHashMap来实现的（这个也是我们常说的”Spring Bean底层是靠HashMap管理的“中的HashMap）

在上述的操作完成后，我们就可以使用 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了


### 容器的生命周期

BeanFactory中定义了Bean的规范与如何获取Bean

```java
// 根据bean的名字和Class类型等来得到bean实例    
Object getBean(String name) throws BeansException;    
Object getBean(String name, Class requiredType) throws BeansException;    
Object getBean(String name, Object... args) throws BeansException;
<T> T getBean(Class<T> requiredType) throws BeansException;
<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
```

BeanFactory的实例在AbstractBeanFactory中实现，其重载都调用了doGetBean方法

doGetBean方法的逻辑：

1. 解析Bean的真正name，如果bean是工厂类，还要再name添加`&`前缀
2. 