# SpringBoot更新

:::tip
本文内容会随着SpringBoot的更新而更新
:::

## SpringBoot4

就在不久，SpringBoot4震撼首发，主要的几个更新点在于：

- 全面支持JSpecify，整个系统实现基于JSpecify的空安全
- 全面兼容Java25，与Java始终并肩而行

现在我们一起看看它的几个核心功能更新

## API版本控制

现在我们可以基于API对接口进行版本控制

```kotlin
@RestController  
@RequestMapping  
class HelloWorldController {  
    @GetMapping(value = ["hello"], version = "1", produces = [MediaType.TEXT_PLAIN_VALUE])  
    fun sayHelloV1(): String {  
        return "Hello World"  
    }  
  
    @GetMapping(value = ["hello"],version = "2", produces = [MediaType.TEXT_PLAIN_VALUE])  
    fun sayHelloV2(): String {  
        return "Hi World"  
    }  
}
```

然后通过配置修改如何进行版本的映射

```kotlin
@Configuration  
class ApiConfig : WebMvcConfigurer{  
  
    override fun configureApiVersioning(configurer: ApiVersionConfigurer) {  
        configurer.usePathSegment(1)  
    }  
  
    override fun configurePathMatch(configurer: PathMatchConfigurer) {  
        configurer.addPathPrefix("/api/v{version}", HandlerTypePredicate.forAnnotation(RestController::class.java))  
    }  
  
}
```

现在映射出的API分别是

- `/api/v1/hello`
- `/api/v2/hello`

主流的版本控制有以下几类

- 基于路径的映射（例如/api/v1/hello与/api/v2/hello）
- 基于查询参数（例如/hello?version=1与/hello?version=2）
- 基于请求头（例如X-API-Version: 1与X-API-Version: 2）
- 基于媒体类型标头（例如Accept: application/json; version=1与Accept: application/json; version=2）

我们都可以在WebMvcConfigurer中的configurePathMatch对其进行制作

## 重试注解

现在，SpringRetry可以更加直接的加入到我们的系统中，我们可以直接将`@Retryable`注解使用到指定的方法上进行针对单个方法的重试

默认情况下，对于抛出的任何异常，方法调用都会重试：在初始失败后最多重试 3 次（ `maxRetries = 3` ），并且每次重试之间有 1 秒的延迟。

```kotlin
@RestController  
@RequestMapping  
class RetryController {  
  
    var count=0  
  
    @Retryable(maxRetries = 6)  
    @RequestMapping("/retry")  
    fun retry(): String {  
        while (count<=3){  
            try {  
                throw RuntimeException("Retry")  
            }catch (e: Exception){  
                count++  
                println("count:$count")  
            }  
        }  
        return "Retry"  
    }  
  
}
```

当然，我们可以对重试进行定制

```kotlin
@Retryable(
  includes = MessageDeliveryException.class,
  maxRetries = 4,
  delay = 100,
  jitter = 10,
  multiplier = 2,
  maxDelay = 1000)
```

## 声明式Http客户端

现在我们可以使用声明式的方式在Spring中定义Http客户端

```kotlin
@HttpExchange(url = "https://jsonplaceholder.typicode.com")  
interface WebClient {  
    @GetExchange("/posts/1", version = "1.0")  
    fun getTodo(): String  
}
```

然后在一个Configurer中将其引入

```kotlin
@Configuration  
@ImportHttpServices(types = [WebClient::class])  
class ApiConfig : WebMvcConfigurer{   
}
```

最后就是直接使用

```kotlin
@RestController  
@RequestMapping  
class RetryController(  
    private val cleint: WebClient  
){  
  
  
    @Retryable(maxRetries = 6)  
    @RequestMapping("/retry")  
    fun retry(): String {  
        return cleint.getTodo()  
  
    }  
  
}
```

值得一提的是，除了上述步骤外我们还需要对客户端进行版本管理

```properties
spring.http.serviceclient.default.apiversion.default-version=1.0.0  
spring.http.serviceclient.default.apiversion.insert.header=API-Version
```

