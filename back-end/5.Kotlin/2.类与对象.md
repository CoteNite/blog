# 类与对象

封装的意义是什么？这是很多初学者都会有的疑惑。

我们可以简单的认为封装的目的是安全，通过封装我们在一定程度上让对象的类封闭，使用者在调用对象方法与字段时尽可以通过我们为其设定好的方法来获取，使得一切都在我们的掌握之中。

进一步讲，封装也可以帮我们实现充血模型，通过对get/set方法的修改与重写，我们可以让一个类的字段的设置封死在我们的类中，更加符合开闭原则

继承了Java的特点Kotlin自然也继承了Java面向对象的特点，同时又发展出了自己的特色，这里我们简单来聊一下Kotlin的类与对象

```kotlin
class Person(  
    val name: String,  
    val age: Int  
) {  
  
    var children: MutableList<Person> =mutableListOf()  
  
    constructor(name: String,children: MutableList<Person>,child:Person) : this(name,0) {  
        Person(name,0)  
        this.children = children  
        children.add(child)  
    }  
  
}
```

上面就是一个Kotlin方法的写法

## 构造函数

Kotlin区分为主构造函数和次构造函数，其中主构造函数就是类中的
```kotlin
class Person(  
    val name: String,  
    val age: Int =0, 
) 
```

他表示了创建一个类至少需要哪些参数，我们也可以通过赋默认值的方式让这个参数变为不必须的。

其他的参数（比如上面的Children参数）就是一个不在构造函数中的参数，由于他不在受主构造函数的限制，因此要求我们必须为他赋初值来规避空的问题

除了主构造函数外的函数我们称之为副构造函数

```kotlin
    constructor(name: String,children: MutableList<Person>,child:Person) : this(name,0) {  
        Person(name,0)  
        this.children = children  
        children.add(child)  
    }  
```

副构造函数可以有多个，但返回值必须是主构造创建的类（官方说法叫做委托给主构造函数），同时你可以在副构造函数的函数体中完成你想要的一些操作

## 继承

Kotlin中的类默认是final的，也就是不可以被继承，你可以通过显示的添加open字段来使其打开

```kotlin
open class Father{

}

class Son:Father(){

}
```

需要注意的是，为了空安全，我们必须在继承的时候通过主构造函数传入父类必要的参数

## get/set方法

对于主构造函数中的方法无法直接创建get/set方法，你可以间接的通过这种方式创建

```kotlin
class Son(  
    name: String  
){  
  
    var name: String = name  
        get()=field  
        set(value){  
            field=value  
        }  
      
}
```

特别值得注意的是，在get/set方法中你必须使用特定的field参数来表示当前字段，这个参数是为了避免无限回调的

当你写成

```kotlin
class Son(  
    name: String  
){  
  
    var name: String = name  
        get()=name  
        set(value){  
            field=value  
        }  
      
}
```

这时你调用Son的name方法会直接StackOverFlow，这是因为get方法内部调用name时又会使用name的get方法，接着就会无限下去

## 函数为一等公民

Java8中最受欢迎的新特性应该就是lambda了，Kotlin为了彻底将这一特性融入自己的底层，于是将函数作为自己的一等公民，通过这一特性，使得Kotlin彻底成为一个支持函数式编程的语言

>**头等函数**（first-class function；第一级函数）是指在[程序设计语言](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80 "程序设计语言")中，函数被当作[头等公民](https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%85%AC%E6%B0%91 "头等公民")。这意味着，函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中。有人主张应包括支持[匿名函数](https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0 "匿名函数")（函数字面量，function literals）。在这样的语言中，函数的名字没有特殊含义，它们被当作具有函数类型的普通的变量对待。1960年代中期，[克里斯托弗·斯特雷奇](https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%C2%B7%E6%96%AF%E7%89%B9%E9%9B%B7%E5%A5%87 "克里斯托弗·斯特雷奇")在“functions as first-class citizens”中提出这一概念。

现在你可以这样写代码

```kotlin
fun outfun(innerfun: (i: Int) -> Boolean): Boolean
```

这个函数传入一个入参为int并使用boolean的命名innerfun的函数，在outfunzhe'ge你可以在这个函数中任意的使用test