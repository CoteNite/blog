# 类与对象

封装的意义是什么？这是很多初学者都会有的疑惑。

我们可以简单的认为封装的目的是安全，通过封装我们在一定程度上让对象的类封闭，使用者在调用对象方法与字段时尽可以通过我们为其设定好的方法来获取，使得一切都在我们的掌握之中。

进一步讲，封装也可以帮我们实现充血模型，通过对get/set方法的修改与重写，我们可以让一个类的字段的设置封死在我们的类中，更加符合开闭原则

继承了Java的特点Kotlin自然也继承了Java面向对象的特点，同时又发展出了自己的特色，这里我们简单来聊一下Kotlin的类与对象

```kotlin
class Person(  
    val name: String,  
    val age: Int  
) {  
  
    var children: MutableList<Person> =mutableListOf()  
  
    constructor(name: String,children: MutableList<Person>,child:Person) : this(name,0) {  
        Person(name,0)  
        this.children = children  
        children.add(child)  
    }  
  
}
```

上面就是一个Kotlin方法的写法

## 构造函数

Kotlin区分为主构造函数和次构造函数，其中主构造函数就是类中的
```kotlin
class Person(  
    val name: String,  
    val age: Int =0, 
) 
```

他表示了创建一个类至少需要哪些参数，我们也可以通过赋默认值的方式让这个参数变为不必须的。

其他的参数（比如上面的Children参数）就是一个不在构造函数中的参数，由于他不在受主构造函数的限制，因此要求我们必须为他赋初值来规避空的问题

除了主构造函数外的函数我们称之为副构造函数

```kotlin
    constructor(name: String,children: MutableList<Person>,child:Person) : this(name,0) {  
        Person(name,0)  
        this.children = children  
        children.add(child)  
    }  
```

副构造函数可以有多个，但返回值必须是主构造创建的类（官方说法叫做委托给主构造函数），同时你可以在副构造函数的函数体中完成你想要的一些操作

## 继承

Kotlin中的类默认是final的，也就是不可以被继承，你可以通过显示的添加open字段来使其打开

```kotlin
open class Father{

}

class Son:Father(){

}
```

需要注意的是，为了空安全，我们必须在继承的时候通过主构造函数传入父类必要的参数

## get/set方法

对于主构造函数中的方法无法直接创建get/set方法，你可以间接的通过这种方式创建

```kotlin
class Son(  
    name: String  
){  
  
    var name: String = name  
        get()=field  
        set(value){  
            field=value  
        }  
      
}
```

特别值得注意的是，在get/set方法中你必须使用特定的field参数来表示当前字段，这个参数是为了避免无限回调的

当你协程