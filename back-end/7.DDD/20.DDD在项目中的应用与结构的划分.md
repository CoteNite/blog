# DDD在项目中的应用与结构的划分

零零散散的学习了快一个星期的DDD了，是时候也该实践一下DDD了

（这一部分是我在pull下来了bitbone老哥的课程源码后自己尝试在自己的项目中落地的感悟）

## 聚合

首先是聚合，聚合的首要目的究竟是干什么？

首先，我们必须要了解的是，聚合是一个充血模型，因此我们的聚合渴望干到的事只有一个，**那就是聚合领域下大部分的业务都可以由聚合自己所持有的字段完成（不能完成的后面会说），聚合会将这些业务封装为方法**

因此我们的聚合既有字段，也有业务逻辑。

这里的一个严重的转变是——聚合所持有的字段是要存放到一个SQL或者NoSQL里的，但是聚合一般不会给到用户查看，只是我们用来处理业务的。

这也是CQRS对我们存储的规范，即数据的划分不再想当然，而是按照Command和Query分成两个表

## 仓储

仓储的任务是查找我们的聚合，将聚合拿出，然后等待执行业务使用。

亦或是仓储将聚合一次放入SQL中

## Command

Command向仓储去索要我们的聚合，然后使用聚合提供的方法完成业务

## Policy

Policy是用来作为中转站，持有多个仓储，基于该特性，Policy可以完成业务中一个聚合难以完成的业务

## Event

Event是发生的事实，在风暴图中他可能会引发另一个Command，这一块是在Policy中完成的，因此这里Event的任务就只剩下了通知读模型去做出修改

## 一个最简单的尝试

什么是DDD？

领域驱动软件设计就是DDD！！！

因此我们的代码结构其实不需要上面这么复杂（或者说是标准？）

我们真正要实现的只有：

1. 让仓储去读取聚合
2. 让聚合或聚合间合作去完成大多数的业务逻辑，业务逻辑不再过程式的写在一个Service中，而是由各个聚合（对象）在自己的方法中完成（封装），这才是DDD/面向对象设计的核心
3. 不涉及业务逻辑的对象单独处理（这里可能不好理解，我举个例子，比如你的观看记录，这个东西不像你的会员身份一样会对你的任何操作产生印象，因此就不会涉及任何业务逻辑，他只是展示给你，因此他就是一个纯粹的读模型，这种模型我们不用去涉及聚合，单纯的CRUD就行）

## 什么是读模型的范围？

一个疑惑是什么是读模型，像刚刚的观看记录就是一个显然的读模型，但例子常常不会这么绝对

举个显而易见的例子——用户信息

用户信息是读模型吗？

有人说是！因为用户信息只是展示给用户看的，没啥业务逻辑

有人说不是！因为用户信息有长度限制，有违规词限制