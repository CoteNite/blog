# Akka————一种任务驱动的高并发解决方案

Akka是一门使用Scala语言编写的基于Actor模型解决高并发问题的框架，因此我们先来了解一下Actor的具体含义

## 基于锁的解决方案的问题

首先是传统的OOP无并发的情景，我们可以看一下情景

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251205203225.png)

我们会发现，在单线程OOP的情境下，我们的方法调用是一种栈的感觉，且操作是时序的

但是回到多线程的情景，我们发现一切都乱起来了

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251205204002.png)

在这种情况下，我们会发现方法执行的时序性是完全打乱的状态，我们没有办法很好的去观察方法的执行顺序，也无法保证资源不会因为乱序的执行而出现问题

一个常用的解决这种问题的方式是使用锁，也就是在同一时间内我们只允许一个线程执行这段方法，但是这确实一个十分昂贵的策略

- 锁在现代CPU上十分昂贵，会对性能造成很大的伤害
- 当资源被上锁后，上锁的线程一旦执行到阻塞操作就会导致线程的等待，无法像协程一样自动的将其挂起
- 锁会带来死锁的风险

同时，锁也只是单机部署的解决方案，对于分布式问题来说，虽然可以模拟处分布式锁，但是这仍然会导致更多的新的问题的诞生，同时由于分布式锁一定程度依赖于外部的数据库，因此还需要多保证数据库的安全和稳定

另一方面，分布式锁的效率比本地锁低几个数量级，通常会对扩展施加硬限制。分布式锁协议需要跨多台机器在网络上进行多次往返通信，因此其造成最大的影响就是延迟。

**总结：**

- 对象的封装只在单线程具有保证，如果涉及多线程，由于线程对资源的抢夺，会破坏原有对象封装的安全性与稳定性
- 锁可以在一定程度上解决多线程的问题，但是锁自身的高昂本身就是一个问题
- 锁在本地工作，分布式锁可以解决空间上的问题，但是其对性能也会带来极大的负担

## 假的共享内存

在现代CPU环境下，CPU会自带一个本地缓存区，起到的作用和内存相似，但其被CPU的调用速度是调用内存的数倍，一个核心的操作，本身是先调用并操作自己的缓存区，然后再同步给内存，再通过内存实现各个核心之间消息的同步

但是由于CPU缓存与内存操作之间的速度问题，导致多线程情况下可能出现消息不同步的情况，这个时候我们要使用volatile或原子类来解决这些问题，但是不论是volatile还是原子类，本身也会对性能带来负担，同时对于程序员来说，分清楚哪些类需要原子操作/可见性本身也是一个很难的问题

## Actor模型提供的解决方案

首先我们先来看一下Actor模型提供的好处：

- 允许在不使用锁的情况下强制封装
- 利用协同实体对信号做出反应，改变状态，通过消息来驱动程序的变化

首先，Actor本身不调用方法，而是互相发送消息，Actor在发送完消息后直接开始执行其他的操作，Actor发送消息的线程不会因为发送消息而造成阻塞

对于返回的消息，Actor会对消息的返回做出反应，并在完成当前的消息处理后执行返回，如果发送消息的Actor期望返回值，那么他要么阻塞，要么在同一线程上执行另一个 Actor 的工作。相反，接收 Actor 在回复消息中传递结果。

也就是说，我们通过引入了Actor，通过Actor来代替对象间的方法调用，将方法调用完全委托给Actor来实现，通过两个不同的Actor之间的互发消息来实现A对B方法的调用以及B对A方法的返回

那么对于最初的时序性问题，由于Actor并非真正的方法调用而是基于消息驱动实现，同时Actor强制要求一次只处理一条消息，这就保证了不会出现多线程之间的紊乱

由此而来的另一个问题是：如果Actor只能在一个时间操作一个消息，那处理消息的过程就类似原子操作，这样不会导致性能很差吗

为了解决这个问题，Actor模型采用的是多Actor并发，也就是Actor池的感觉，你可以理解有很多Actor，每个Actor都会进行原子操作，每次接受一个新的消息都是一个全新的Actor在进行操作

对于共享资源来说，我们无法实现对于共享资源的同步化，也就是即时存在复数个Actor，如果要操作同一个资源，本身还是要互相等待，但这不是Actor模型的问题，换言之，目前的所有多线程模型都无法解决共享资源等待的问题，你也可以理解成这就是造成问题的根源，你要解决的是用于共享资源导致的问题而不是共享资源本身

Actor模型本身提供的解决方案是：让资源本身变成Actor，即对于一个共享资源，我们将其封装为一个Actor，然后由于共享资源的性质，这个Actor是唯一的，但是其操作是原子的，这就解决了多线程操作下共享资源由于多个线程共同操作以及CPU缓存区与内存的不一致性照成的错误，你也可以理解为Actor本身就是一种通过一种类似原子类的方式解决的共享资源方面的问题

需要注意的是，Actor的这种原子性其实是一种逻辑原子性，这是因为Actor处理消息期间不会并发执行其他消息，这就导致处理一条消息过程就是一个原子事务，所以Actor的“原子性”是在 Actor的执行模型保证的，而不是 CPU 层的 CAS 那种原子，它是“逻辑原子性”，不是“指令级原子性”。

反观我们使用CPU层实现的原子操作，会出现的问题：

- 数据竞争（race condition）
- 缓存不一致（CPU cache coherence）
- 指令重排序
- 需要加锁、锁竞争、死锁、活锁

由于Actor模型通过实现同一时刻只能操作一条消息的特性，导致上述的问题都不会出现，进一步讲，Actor解决这些问题的方式是将原本在CPU层的解决方案引入到了我们的代码层面解决，通过队列的方式实现消息的单一处理

为了解决这些问题，一个Actor至少有一下的设施：

- 一个邮箱（消息结束的队列）。
- 一个行为（Actor 的状态、内部变量等）。
- 消息（表示信号的数据片段，类似于方法调用及其参数）。
- 一个执行环境（一种机制，它让具有消息的 Actor 对其消息处理代码作出反应并调用它们）。
- 一个地址（稍后将详细介绍）。

这是一个非常简单的模型，它解决了前面列举的问题：

- 通过将执行与信号分离（方法调用转换执行权，消息传递不这样做），可以保留封装。
- 不需要锁。修改 Actor 的内部状态只能通过消息来实现，一次处理一条消息，在试图保持不变时消除竞争。
- 任何地方都没有使用锁，发送者也不会阻塞。数百万个 Actor 可以有效地安排在十几个线程上，从而充分发挥现代 CPU 的潜力。任务委托是 Actor 的天然执行方式。
- Actor 的状态是本地的而不是共享的，更改和数据通过消息传播，消息是映射到现代内存架构的实际工作方式。在许多情况下，这意味着只传输包含消息中数据的缓存线，同时将本地状态和数据缓存在原始核心上。相同的模型可以完全映射到远程通信中，其中状态保存在机器的 RAM 中，更改/数据作为数据包在网络上传播

