# Akka————一种任务驱动的高并发解决方案

Akka是一门使用Scala语言编写的基于Actor模型解决高并发问题的框架，因此我们先来了解一下Actor的具体含义

## 基于锁的解决方案的问题

首先是传统的OOP无并发的情景，我们可以看一下情景

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251205203225.png)

我们会发现，在单线程OOP的情境下，我们的方法调用是一种栈的感觉，且操作是时序的

但是回到多线程的情景，我们发现一切都乱起来了

![image.png](https://raw.githubusercontent.com/CoteNite/Blog_img/master/blogImg/20251205204002.png)

在这种情况下，我们会发现方法执行的时序性是完全打乱的状态，我们没有办法很好的去观察方法的执行顺序，也无法保证资源不会因为乱序的执行而出现问题

一个常用的解决这种问题的方式是使用锁，也就是在同一时间内我们只允许一个线程执行这段方法，但是这确实一个十分昂贵的策略

- 锁在现代CPU上十分昂贵，会对性能造成很大的伤害
- 当资源被上锁后，上锁的线程一旦执行到阻塞操作就会导致线程的等待，无法像协程一样自动的将其挂起
- 锁会带来死锁的风险

同时，锁也只是单机部署的解决方案，对于分布式问题来说，虽然可以模拟处分布式锁，但是这仍然会导致更多的新的问题的诞生，同时由于分布式锁一定程度依赖于外部的数据库，因此还需要多保证数据库的安全和稳定

另一方面，分布式锁的效率比本地锁低几个数量级，通常会对扩展施加硬限制。分布式锁协议需要跨多台机器在网络上进行多次往返通信，因此其造成最大的影响就是延迟。

**总结：**

- 对象的封装只在单线程具有保证，如果涉及多线程，由于线程对资源的抢夺，会破坏原有对象封装的安全性与稳定性
- 锁可以在一定程度上解决多线程的问题，但是锁自身的高昂本身就是一个问题
- 锁在本地工作，分布式锁可以解决空间上的问题，但是其对性能也会带来极大的负担

## 假的共享内存

在现代CPU环境下，CPU会自带一个本地缓存区，起到的作用和内存相似，但其被CPU的调用速度是调用内存的数倍，一个核心的操作，本身是先调用并操作自己的缓存区，然后再同步给内存，再通过内存实现各个核心之间消息的同步

但是由于CPU缓存与内存操作之间的速度问题，导致多线程情况下可能出现消息不同步的情况，这个时候我们要使用volatile或原子类来解决这些问题，但是不论是volatile还是原子类，本身也会对性能带来负担，同时对于程序员来说，分清楚哪些类需要原子操作/可见性本身也是一个很难的问题

## Actor模型提供的解决方案

首先我们先来看一下Actor模型提供的好处：

- 允许在不使用锁的情况下强制封装
- 利用协同实体对信号做出反应，改变状态，通过消息来驱动程序的变化

首先，Actor本身不调用方法，而是互相发送消息，Actor在发送完消息后直接开始执行其他的操作，Actor发送消息的线程不会因为发送消息而造成阻塞

对于返回的消息，Actor会对消息的返回做出反应，并在完成当前的消息处理后执行返回，如果发送消息的Actor期望返回值，那么他要么阻塞，要么在同一线程上执行另一个 Actor 的工作。相反，接收 Actor 在回复消息中传递结果。


