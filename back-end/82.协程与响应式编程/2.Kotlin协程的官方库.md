# Kotlin协程的官方库

Kotlin官方为我们提供的协程启动方法是launch方法，所以我们可以先试一下

```kotlin
launch{

}
```

我们会发现存在一个警告，这是因为Kotlin希望我们的launch方法全部基于一个Scope，我们先来试一下GlobalScope

```kotlin
GlobalScope.lauch{

}
```

现在我们会发现lauch没问题了，但是GlobalScope却出现了问题就没问题了，这是因为GlobalScope不够安全，没有结构化并发的功能

当前Kotlin推荐的协程书写方法是基于`CoroutineScope`来实现，CoroutineScop为我们提供了一种结构化并发的协程模型，即如果父协程失败或被取消，子协程也会被递归的取消，这种方式更加的安全

如果想要创建结构型，则需要使用coroutineScope方法

```kotlin
fun main():Unit = runBlocking { //这里使用runBlocking是因为coroutioneScope本身是一个挂起方法
    coroutineScope {  
        this.launch {  
            this.launch {  
                delay(2.seconds)  
                println("Child of the enclosing coroutine completed")  
            }  
            println("Child coroutine 1 completed")  
        }  
        this.launch {  
            delay(1.seconds)  
            println("Child coroutine 2 completed")  
        }  
    }  
}
```

我们再来看一下lauch方法

```kotlin
public fun CoroutineScope.launch(  
    context: CoroutineContext = EmptyCoroutineContext,  
    start: CoroutineStart = CoroutineStart.DEFAULT,  
    block: suspend CoroutineScope.() -> Unit  
): Job {
	//。。。
}
```

context我们并不陌生，就是我们之前提到的协程上下文，而start是指协程的启动模式，协程启动模式分为四种

- DEFAULT：协程创建后，立即开始调度，在调度前如果协程被取消，其将直接进入取消响应的状态。
- ATOMIC：协程创建后，立即开始调度，协程执行到第一个挂起点之前不响应取消。
- LAZY：只有协程被需要时，包括主动调用协程的start、join或者await等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态。
- UNDISPATCHED：协程创建后立即在当前函数调用栈中执行，直到遇到第一个真正挂起的点。

