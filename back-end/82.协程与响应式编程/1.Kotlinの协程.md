# Kotlinの协程

众所周知，在Kotlin协程发布的时候，Java的 VirtualThread还不知道在哪呢，那么和Java互通的Kotlin是如何实现的协程呢？

**基于Thread进行包装**

这是目前主流的协程设计方案~~虽然实践不同，但Go语言实际上也是通过维护线程的方式实现的协程~~

而作为~~Google私生子的~~Kotlin在一定程度上借鉴了Go语言协程的优秀设计，同时有对老牌的Java多线程方案进行了参考~~谢谢你RxJava~~，也就形成了我们现在使用的Kotlin协程

## 协程的使用

```kotlin
fun main(){  
  
    CoroutineScope(Dispatchers.IO).launch {  
        sleep(2000L)  
        println("协程内")  
    }  
  
    println("协程外")  
}
```

我们往往会使用CoroutineScope.launch{}的方式启动一个协程，协程的内容就是在代码块中执行的，其中协程和当前线程是并行的，也就是两者互不干预

CoroutineScope会要求我们传入一个参数，这个参数用于定义协程的上下文

这里的Dispatchers叫做协程调度器，用于定义协程是以何种方式运行（或者说是协程底层的线程池是如何实现的），常用的基本只有三个

- Dispatchers.Default：用于CPU密集型操作
- Dispatchers.IO：用于IO密集型操作
- Dispatchers.Main：用于客户端程序，指明当前协程实在UI线程上运行，如果是服务端程序（比如SpringBoot程序），使用该调度器会报错

当然，Kotlin也为我们提供了自定义调度器的方法，但是不算常用，这里就不提了（希望在JDK25之后能够提供Dispatchers.VT版本的调度器）

## 父子协程




