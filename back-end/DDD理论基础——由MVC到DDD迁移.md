# 由MVC到DDD

## 为什么要DDD

DDD出现前主流的开发模式使用的是MVC架构，但项目写大了很容易就会发现MVC架构存在很多潜在的问题

## 原有MVC架构的问题

首先MVC中的核心层为service层，在service层中，大量的业务逻辑被堆积在这里，而反观其他的层次，Dao/Mapper层的逻辑太少，主要就负责联系数据库，Controller层这是简单的调用Service层的方法，也不存在大量的逻辑。且随着业务的推挤，很有可能会出现Service间互相调用，多个Service调用多个Dao的情况，项目耦合过于严重，在这种情况下，我们必须要想一个办法实现架构的低耦合和高内聚。

## DDD的尝试

### 六边形架构

DDD在原有的基础上对项目进行了拆分，主要分为以下几层

* **app层：**该层为整个springboot项目的启动器，主要完成一些配置和一些方法使用前/后的东西

  该层下的分块

  * Application类：Springboot应用启动类
  * config包：里面定义类一堆xxxConfig作为各种导入包的配置类
  * aop包：用来定义一些切面，解决一些通用的配置
  * **注意：**我们整个项目的test和resource也是在这一层中

  作为整个项目的启动层，该层不涉及业务逻辑，主要负责完成启动整个项目

* **types层：**该层为整个项目的通用类型定义层

  * enums包：通用枚举
  * common包：通用实体类
  * event包：通用信息事件，主要作为一些MQ的出入参，定义了一个标准，需要具体跟据MQ的不同进行实现
  * expection包：通用异常类
  * model包：返回给前端的通用格式，主要给trigger层/apu层使用

  作为整个项目的通用类定义处，该层只能用于放高度通用的东西，且该层里所有类不能包含任何业务

* **api层：**该层定义对外接口的规范（即在该层声明了controller层的方法）

  该层下的分块

  * xxxService：接口类，定义接口用于trigger的http包实现
  * dto包：该包下含有大量的dto，dto为对外实体，大多是通过网络来得到或者给出的数据，用于作为xxxService的出入参

  作为整个项目的接口层，该层更多的是服务于trigger层，为trigger提供一个标准

* **trigger层：**该层主要负责被动对外获取数据或给予数据，通过调用domain层将数据带到业务中

  该层下的分块

  * http包：被前端触发，用于实现api层的接口，原MVC架构中的controller类就在该包中存放
  * job包：被定时任务触发，用于定义一些定时任务
  * listener包：被MQ触发，用于定义Listener

  作为整个项目的触发层，该层主要负责被动的获取信息或者给出信息，也就是说该层类的方法不被任何其他层使用，仅仅关注其他包为我们提供的方法，然后给予入参，返回出参给前端。

* **domain层：**领域层，DDD最核心的层，该层内以不同领域区分包（后续简称领域包），每个领域包下又下设model，repository和service三个包，用于实现业务的核心逻辑

  该层下的分块

  * model包：该包用于定义带有参数的类，常被用于出入参

    该层下的分块

    * entity包：实体包，该包定义大量实体，主要是与持久化数据形成1v1或1vn的关系，用于将PO数据拿到我们的程序中
    * aggregate包：聚合对象包，我们在写代码时就会发现，有时一个方法的传参出差除了一个实体类外可能还需要其他基本类型（或者根本一个实体类就不够），这时我们就会选择在该包中定义aggregate类，来实现对参数的聚合
    * VO包：值对象，其实上面的分类有明显的漏洞，就是我们如果需要一些不是持久化数据的类怎么办，这个时候我们就可以选择使用VO类来定义，该包中的VO类为一些一旦创建就不会修改的数据，且这些数据不会被直接的持久化，主要用于业务中或是作为Entity类的内部参数。

  * adapter包：该包主要负责与infrastructure层进行沟通，作为标准的定义者来被infrastructure实现或调用

    该包中的包有

    * event包：types层里的event的具体实现，有时会放在实体类中作为实体类的一部分，给到infrastructure层来发布给MQ
    * repository包：该层仅定义标准，用于外部数据（本地），具体实现交由infrastructure层处理
    * port包：该层仅定于标准，用于外部数据（网络），具体实现交由infrastructure层处理

  * service包：存放原本MVC中的service类，主要负责实现业务，该包下即为业务接口的定于与具体实现，service类接受trigger层的调用，并将trigger层给到的数据完成业务处理后反馈给trigger层。同时该层还会通过调用repository包中的类来完成数据的获取或者存放

  作为整个项目的核心层，**领域层实现了一个中转**，通过被trigger层调用完成对外的被动调用，同时通过repository包对infrastructure层的定义以依赖倒置的形式完成了对外部数据的获取。正是通过这样的一套逻辑，DDD实现了项目的低耦合和高内聚

* **infrastructure层：**该层主要负责主动对外获取或者存放数据

  该层下的分块

  * event包：存放publisher类，用于发布数据到MQ

  * gateway包：通过网络来获取数据或发送数据给外部,为adapter服务

    该包下的包

    * rpc包：通过rpc获得外部数据
    * http包：通过http获得外部数据
    * dto包：为上面两个包提供对象作为出入参

  * dao包：原本MVC里的DAO/Mapper，为adapter服务，用于从数据库中存取数据，**下设po包存放数据库类型，PO与数据库完全对应（但为了查询速度，取的时候不用全部取出每一列）**

  * redis包：用于沟通redis存取数据

  * adapter包：该包主要负责与domain层沟通，实现domain层adapter内定义的多个标注

    该包中的包有

    * event包：沟通MQ，发布domain定义的event数据到MQ
    * repository包：沟通本地数据，将Entity/VO/Aggreate转化为PO并调用Dao来存放到本地，或者直接调用Dao获取本地数据转化为Entity/VO/Aggreate的形式给到domain层
    * port包：沟通网络数据，将Entity/VO/Aggreate转化为dto并通过调用port发送给外部，或者直接调用port获取外部数据转化为Entity/VO/Aggreate的形式给到domain层

这就是所谓的**DDD六边形架构**（因为分了六个层），通过这个架构形式实现了整个项目的低耦合和高内聚。

### 一些我的想法

#### 低耦合

为什么六边形架构就能实现低耦合呢？以下是我的一些想法。

首先思考一个问题，**将业务完成需要几步？**只需三步！

1. 接收到外界指令
2. 执行指令
3. 返回执行结果给外界

这就是那个经典的大象冰箱的故事，而DDD正是抓住了这一点来完成的解耦与内聚。

我们找到MVC中架构中高耦合和低耦合的部分

* 低耦合：不涉及到业务，没有什么复杂部分
  * **config类和AOP类不会被其他其他层**，因此DDD将其单独拆分出来，又因为这些类与项目的启动与运行密切相关，同时还不涉及到业务，**因此被我们放到了app层里**
  * 一些通用的数据虽然经常被调用，但由于其本身通用的性质也不涉及什么耦合，因此也被我们单独抽离出来放到了types层
* 高耦合：设计业务，可能多次相互
  * service中常常会出现相互调用的情况，因此我们将service层的核心逻辑单独抽离出来，并将核心逻辑部分抽出为domain层
  * controller/job/listener因为主要是调用service，因此也被单独抽离出来放到了trigger层（定义标准）和api层（实现接口/标准）中
  * dao/redis/网络存取数据虽然不常常互相调用，但由于与service密切相关，因此也被抽离出来放到了infrastructure层中

我们再回看那三步

首先排除调api层（该层为trigger层服务，因此只需要讨论trigger层），app层和types层（该层为整个项目服务，因此无需讨论）

1. **接收到外界指令**

   这一步由trigger层完成，同时trigger层简单处理完数据（将dto转化为entity等）后通过调用domain层的service包下的类来完成核心业务。

2. **执行指令**

   这一步由domain层与infrastructure共同完成，保存发送数据由infrastructure完成，处理数据/任务由domain层完成，且一个指令很有可能既需要处理也需要保存。

   由于涉及到两个层，因此很容易耦合。

   DDD为了解决这个问题选择了依赖导致的方案，让domain层管控infrastructure层，通过在adapter包中定义标准实现依赖倒置的方式来解除了耦合，domain不需要知道infrastructure的具体实现有什么，只需要将标准定义好再使用即可。

   而infrastructure层实现了domain层的标准，只负责完成domain层给的任务即可。

3. **返回执行结果给外界**

   由于infrastructure层受domain层的管控，因此trigger只需要调用domain层的方法就可以获得我们要的结果，在返回给外部。

通过这样的形式，DDD完成了对整个项目的解耦

#### 高内聚

高耦合的问题解决了，接下来我们来实现低内聚的问题

**贫血模型**

在MVC架构中，实体类大多只存放数据，不涉及业务逻辑，而具体业务交由service层处理，这种模型我们称呼为贫血模型，也正是这种设计模式导致了MVC架构的低内聚

而DDD的设计中，我们强调抛弃这种设计模式，采用一种高内聚的设计模式，我们称呼他为充血模型

**充血模型**

充血模型认为如果一个类中如果可以只靠其内部数值就可以完成一定的数据处理，那就没有必要交给外部类处理，而是在自己内部定义方法完成，同时将这个方法暴露给外部，通过被外部调用接收到外部参数，同时返回外部需要的数据即可。

**充血包**

对于充血模型，后来又发生了进一步延申，即除了类外，我们的一个包也可以采用充血模型的形式进行设计，即一个包下核心业务拆分给各各子包处理，同时只需对外开放一个接口起到类似文档的作用即可。

在这样的设计下，DDD的业务被高度浓缩在了一下块，因此也就实现了高内聚



