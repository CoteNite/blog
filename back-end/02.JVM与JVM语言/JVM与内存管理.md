# JVM与内存管理

Java在运行时会将自己内部的内存划分为几个不同的区域，这些区域的总称叫做运行时数据区，根据Java虚拟机规范规定，JVM中运行时区域分为：

- 方法区
- 虚拟机栈
- 本地方法栈
- 堆
- 程序计数器

## 程序计数器

这块区域用来控制Java的运行流程（下一条应该执行哪个指令），在一个已知的时刻，一个内核只会执行一个线程中的指令。由此，在多线程编程中，该区域承担着保证线程切换后能恢复到之前的状态继续执行的功能，因此每个线程都会有一个独立的程序计数器，这一块是线程私有的内存。当当前线程执行的是Java方法时，此处存放的是一个虚拟字节码的地址，而执行的是Native方法时，存储的则是空（Undefined）

这块区域是在《Java虚拟机规范》中唯一一个没有规定OOM情况的区域

## Java虚拟机栈

类似C语言的栈，在进行方法调用时，JVM也会向栈中弹入一个栈帧，这个栈就是Java虚拟机栈。

由于每个线程都有自己的一套方法调用顺序，因此虚拟机栈也是线程独有的。虚拟机栈的每个栈帧中存放了当前方法的局部变量表、操作数栈、动态连接、方法出口等信息，直到该方法完全执行完毕，这个栈帧才会被弹出栈

局部变量表中存放了当前方法的所有局部变量，包含八种基本类型，对象引用和returnAddress
类型（指向了一条字节码指令的地址）

《Java虚拟机规范》中规定这个地方存在两种异常：

- 由于栈扩展时无法申请到足够的空间而导致的OOM（在HotSpot虚拟机中栈容量不可以扩展，所以不会因为扩展出现OOM，只要线程申请栈成功了就不会OOM，只有栈申请）
- 由于线程请求的栈深大于虚拟机栈最大允许的栈帧而导致的StackOverflowError

## 本地方法栈

与虚拟机栈类似，之哦是服务的对象是Java中的Native方法



