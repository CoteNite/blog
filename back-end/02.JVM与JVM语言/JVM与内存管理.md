# JVM与内存管理

Java在运行时会将自己内部的内存划分为几个不同的区域，这些区域的总称叫做运行时数据区，根据Java虚拟机规范规定，JVM中运行时区域分为：

- 方法区
- 虚拟机栈
- 本地方法栈
- 堆
- 程序计数器

## 程序计数器

这块区域用来控制Java的运行流程（下一条应该执行哪个指令），在一个已知的时刻，一个内核只会执行一个线程中的指令。由此，在多线程编程中，该区域承担着保证线程切换后能恢复到之前的状态继续执行的功能，因此每个线程都会有一个独立的程序计数器，这一块是线程私有的内存。当当前线程执行的是Java方法时，此处存放的是一个虚拟字节码的地址，而执行的是Native方法时，存储的则是空（Undefined）

这块区域是在《Java虚拟机规范》中唯一一个没有规定OOM情况的区域

## Java虚拟机栈

类似C语言的栈，在进行方法调用时，JVM也会向栈中弹入一个栈帧，这个栈就是Java虚拟机栈。

由于每个线程都有自己的一套方法调用顺序，因此虚拟机栈也是线程独有的。虚拟机栈的每个栈帧中存放了当前方法的局部变量表、操作数栈、动态连接、方法出口等信息，直到该方法完全执行完毕，这个栈帧才会被弹出栈

局部变量表中存放了当前方法的所有局部变量，包含八种基本类型，对象引用和returnAddress
类型（指向了一条字节码指令的地址）

《Java虚拟机规范》中规定这个地方存在两种异常：

- 由于栈扩展时无法申请到足够的空间而导致的OOM（在HotSpot虚拟机中栈容量不可以扩展，所以不会因为扩展出现OOM，只要线程申请栈成功了就不会OOM，只有申请栈内存失败时才会出现OOM）
- 由于线程请求的栈深大于虚拟机栈最大允许的栈帧而导致的StackOverflowError（eg.过多的递归）

## 本地方法栈

与虚拟机栈类似，只是服务的对象是Java中的Native方法

## Java 堆

这块区域是所有线程共有的，根据《Java虚拟机规范》，几乎所有的对象实例的内存都是在这里分。由于这里是对象内存分配的位置，因此GC也在这里发生，故而又名为GC堆。由于对象的内存是在Java堆中开辟的，因此当没有足够的内存时就会出现OOM

## 方法区

方法区也是线程共有的内存区域，用于存储类型信息，常量，静态变量等数据，根据《Java虚拟机规范》，这块区域在逻辑上属于Java堆的一部分，但又专门使用了“Non-Heap”这一词汇来与Java堆进行区分。

在JDK8之前，存在一个叫做永久代的东西，这时HotSpot团队对方法区的实现方式，其他的JVM是没有永久代这个说法的，最初设计永久代是希望可以通过Java堆的GC一同将永久代的数据进行回收（是的，即时进了永久代也不能表示数据真正”永久“，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载），但是根据实际情况发现这一设计会导致很多Bug（主要是永久代的GC不理想照成的内存泄漏），因此在JDK8及以后的版本中彻底放弃了永久代的设计

由此我们不难发现，如果方法区无法满足内存分配需求，也会产生OOM

## 运行常量池

运行时常量池是方法区的一部分，承载了Class文件中的常量池表（内含编译期生成的各种字面量与符号引用）中的内容，运行常量池中处理符号引用外也会存放由符号引用转换而成的直接引用

当常量池无法再申请到内存时会出现OOM

## 对JVM中区域的总结

JVM作为Java乃至后续各种JVM语言的基石，其设计一定是相当合理的，JVM中的每一个区域都有自己的意义，共同实现JVM语言的运行。

- **虚拟机栈**：本质上实现的其实是语言中执行流程的问题，即单线程中下一句应该执行哪个代码，多线程中如何在切换线程时切换回原本的状态
- **虚拟机栈+本地方法栈**：解决方法调用方法的问题，以及隔离不同方法间各自的信息，进而实现了函数的各项功能
- **Java堆**：解决对象创建后内存分配以及生命周期的问题，实现了对于对象的托管
- **方法区+运行时常量池**：存储类的基本信息（类的元数据（类名、父类、接口、修饰符等），字面量（如字符串常量)， 符号引用（如类名、字段名、方法名等）等），是实现OOP的基石


## 直接内存

在Java1.4中新增的NIO中，我们可以直接通过Native函数库来直接分配堆外内存，然后通过DirectByteBuffer类来对这块内存进行操作，由于是直接操作物理内存，不用来回在Native堆和Java堆中拷贝，因此性能极高，但是内存肯定不可能是无限的，因此也会出现OOM的情况

## 对象实例的创建

一般Java程序会在检测到new关键字的时候创建对象，在创建对象前，JVM会现在常量池中尝试定位这个类，如果定位不到，就说明这个类还没有被加载，那么则会先进行加载

加载完成后，会先试图为实例开辟一段空间，根据JVM中内存是否规整（即是否完全分为两块区域：已使用和未使用，这两块区域应该相互隔离）存在两种方案：

- 当内存不规整时：JVM会维护一个空闲列表，用来记录哪些内存未被使用，当创建对象时，就从空闲列表中寻找一片空间给程序
- 当内存规整时：JVM会采用指针碰撞的形式，直接将用来分隔空闲区和非空闲区的指针进行移动，进而将空闲区的空间移动给非空闲去

为了保证空间分配这一过程的线程安全，JVM默认采用CAS+错误重试的机制来实现分配内存的原子性，除此之外还有一种模式就是给每个线程预先分配一段空间，线程创建对象只能在这个空间中创建，但该方式需要单独开启

再分配完空间后，会将空间中除了对象头的部分置为0，然后对对象头中数据进行设置（包含hashCode（这一部分是Lazy加载的，只有调用方法的hashCode方法才会得到），元数据，GC年龄等），上述过程完成后就视为在JVM层面创建了一个对象实例

不过在代码层面，还要执行构造方法，init方法，来完成实例中字段的传入

## 对象的布局

对象分为三部分：对象头，实例数据，对齐填充

其中对象头中包含两类数据，一类是存储对象自身运行时的数据，则个数据中包含哈希码，GC分代的年龄，锁状态的标志等内容，这一部分被精心设计为了32bit或64bit（根据你的系统是32位还是64位决定）

对象的另一部分为类型指针，用来表示这个对象实例对应的是哪个类。

然后是实例数据，就是程序员设计的字段的数据。

最后是对齐填充，由于HotSpot虚拟机中要求对象必须是8字节的倍数，因此会使用该空间将整个对象填充至8的倍数

## 对象的访问

我们都知道Java是通过引用直接访问到Java堆中开辟的对象，那么引用是如何访问到Java堆中的对象呢

对于JVM一般的实现方式有两种：

- 引用指向句柄池：在Java堆中专门设置一块空间，用来存放句柄，句柄包含两部分，一部分是对象示例数据的指针（指向Java堆中的Java类实例对象），另一部分则是指向方法区中的类信息
- 引用指向实例数据：使用指针直接访问对象实例，同时在对象实例中存储一个用来访问类信息的指针

一般JVM都是采用指向实例数据的方式，因为这种方式少一次定位，速度更快

## 实战——JDK String常量池在不同JVM下的区别

```java
  public static void main(String[] args) {
        String str1 = new StringBuilder("计算机").append("软件").toString();
        System.out.println(str1.intern() == str1);
        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
```

这段代码在JDK6，7，17中均有不同的答案：

- JDK6：false false
- JDK7：true false
- JDK17：true true

在JDK6中String的intern方法会把第一次遇到的字符串实例放入永久代/方法区中的字符串常量区，返回的是永久代中这个这个字符串实例的引用，而使用StringBuilder创建的字符串是直接创建在Java堆上的

而在JDK7中，永久代中的字符串常量区被移动到了Java堆上，记录的也变成了Java堆中这个实例的引用，对于str1，由于是第一次遇到，因此将这个字符串的引用放入字符串常量区，并放回回来，而str1本身就是这个字符串引用，因此一样，而str2，因为Java在类加载阶段中会加载这个字符串（这个字符串比较特殊），因此这里获取的是类加载时的字符串的引用

而在JDK17中，**HotSpot不会再在类加载过程中加载字符串到常量区**，因此str2与str1完全相同，故是两个true

## 垃圾回收

主流的垃圾回收方式有两种——引用计数法和可达性分析法

引用计数法相对简单，一个对象在创建时添加一个引用计数器，每被引用一次引用计数器+1，引用失效则计数器-1，凡是计数器数值为0的对象均是无法被使用的

但是引用计数法会在一些特殊的情况下造成引用内存泄漏

```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
}
```

比如这个代码，虽然objA和objB都为null吗，但是其内部互相引用仍然存在，因此就出现了内存泄漏

于是就产生了可达性分析法

可达性分析法会设置一个特殊的对象作为GCRoots，一个对象根据自身的引用关系（比如A引用B，B引用C）向上找，凡是能达到GCRoots的就是不可回收的，反之就是可回收的

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如
NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

## 引用的区别

所谓引用就是指一个reference类型的数据里存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。根据垃圾回收的机制，一个对线的引用的存在与否直接关乎对象是否会被回收

根据引用类型的不同，Java1.2后将引用区分为强引用（Strongly Re-ference）、软
引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种

强引用就是我们平常使用new关键字创建的引用，其会根据上面说的回收方式进行回收，一般只要对象存在强引用就不会被回收

软引用则是在系统即将发生内存泄漏前进行检测，如果会发生内存泄漏，则将只有软引用的对象全部回收

弱引用则是在下一次垃圾回收中一定会回收的引用，如果一个对象在下次回收中只存在弱引用，那么它必将会被回收

虚引用无关对象的存活，唯一的意义就是在对象被垃圾回收时会给到一个通知

## 对象的”自救“

在对象被正式回收前，其实还有一次自救的机会，因为对象回收前会进行一次筛选，赛选的条件是对象是否要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

如果一个对象有必要执行finalize()方法，则会进入一个名为F-Queue的队列，在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法，在这个finalize方法中，对象有机会创建自己的引用，进而让自己避免被回收的命运

值得注意的是，finalize()方法并不是一个好的方法，这是Java诞生之初为了方便C/C++程序员转型做出的妥协，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。

有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好更及时，因此我们可以放弃使用这个方法

## 垃圾收集算法的基石——分代收集理论

现代的垃圾收集算法大多都基于分代收集理论，这是一套经验理论，建立在三个假说之上：

- 弱分代假说：绝大多数的对象都是招生夕死的
- 强分代假说：经过多次垃圾回收还没有被回收的对象都是难以回收的
- 跨代引用假说：不同分代的引用只占所有引用的一小部分

首先根据前两个假说，我们可以得到：

- 大多数对象都是创建后没多久就被回收了
- 很久没被回收的对象那大概率永远都不会被回收

因此我们可以得到结论：要将堆分成两部分，其中一部分较大，用来存放新生的对象，另一个部分较小，用来存放回收了好久都没有被回收的对象，这样我们就能发现，我们只需要对前者进行频繁的垃圾回收，偶尔对后者进行垃圾回收即可

这也就说所谓的新生代和老年代的由来。

第三个假说的作用是为了解决如果存在跨代引用，比如新生代被老年代引用，那么我们在回收新生代的时候，就需要完成一次涉及到老年代的可达性检验，而老年代的引用又很可能相互交织，这就导致这一次回收变成了“全”回收

而根据第三个假说——跨代引用很少，就可以得出，我们只需要对这一小部分单独检查即可，因此现代JVM中会将老年代分为多块，然后专门在新生代上开辟一块空间，名为记忆集，记录老年代的哪一块存在跨代引用，让后单独处理即可

## 堆的空间划分

根据上面的假说，我们也就将堆分为了两部分——老年代和新生代，其中新生代存放的是创建时间较短的对象，老年代存放的是创建时间较长的对象

大多数的GC发生在新生代上
## 三种回收算法

### 标记-回收算法

会对引用进行一次可达性检验，然后标记要回收（也可以标记不可回收的，主要是要标记一下）对象，然后对整个内存进行一次“从左到右”的回收，把要回收的部分回收掉即可

标记-回收算法最大的问题在于，这样会产生很多的内存碎片（因为你无法确定回收的对象是否连续），且标记过程时间完全随着对象的数量增长而增长

### 标记-复制算法

标记复制算法将内存区域分为两个半区，每次只在一个半区上创建对象，当这个半区的内存使用完后，会将这个半区的数据存货的对象全部复制到另一个半区，然后将回收的对象全部清除，这样就保证了对象永远都创建在一个连续的空闲空间上。

这个算法的问题是会产生大量的内存复制开销，并且可以创建对象的空间缩小到了原来的一半。**不过这仍然是大多数JVM默认的回收算法**（比如 HotSpot 的 **Serial GC、Parallel GC、G1 的 Young GC** 都在新生代使用它）

根据三大假说，我们知道，一次回收中只会有一小部分的对象会仍然存活，因此就对半区复制进行了优化，即将新生代分为一个较大的Eden空间和两个较小的Survivor空间，创建对象时，会将对象创建在Eden和其中一个Survivor上，然后垃圾回收时，会将存活的对象放到另一个Survivor上，然后清空被回收的Eden和Survivor

一般Eden：Survivor是8：1的大小，但是仍然可能产生Survivor空间不够放置回收后存活的对象的情况，所以当用来存放存活对象的Survivor不够用时，会将一部分存活对象移植老年代，直到老年代也不够用才会报错

### 标记-整理算法

上面的两种算法基本都是用在新生代，而在老年代则使用另一种算法——标记-整理算法

与标记-回收算法相同，标记-整理算法都会先进性标记，但不同之处是会将回收后存活的对象进行整理，保证这些对象使用的是一块连续的内存区域，然后将死亡的对象回收掉，这样也保证了对象在一块连续的区域上

但是对于一个运行的程序，尤其是老年代这种几乎不会回收对象的区域，做对象内存移动是很危险的，因此老年代GC时的整理过程会暂停整个程序的运行，直到GC完成，这个过程又被设计者戏称为“Stop The World”（Dio音~）

## JVM的暂停

由于主流的JVM采用的是可达性分析来判断一个对象是否应该被回收，因此我们**要在回收的最初**就要先找到所有的GCRoots（GCRoots的枚举），这一过程也是要进行类似如同上文提到的Stop the world的暂停所有线程的过程，这是因为我们在枚举的这一刻不能允许存在指令对对象的引用进行修改，不然我们就无法保证回收的准确性

既然要寻找GCRoots，那么就要先知道哪些内存区域中存放有对象，HotSpot虚拟机中采用的是一种叫做OopMap的数据结构，这个数据结构中存储了**在这一刻**内存的哪些区域上有对象

由于每一行指令都有可能改变对象的引用关系，那么如果对个指令都进行OopMap的修改，则是一个十分耗时耗力的操作。因此JVM只会在一些特定的位置进行OopMap的记录，这些位置被称之为**安全点**

一般我们会在安全点对OopMap进行修改，并且进行GCRoots的枚举，那么现在的问题就是如何能保证在某一个时刻所有的线程都进入到安全点并暂停

主流的方案是主动式和抢占式

抢占式是JVM首先暂停所有线程，然后检测各个线程当前是否在安全点，如果不在则让线程继续运行，直到运行到运行到最近的安全点停止线程来响应GC

主动式是线程不断轮询检测自己受否运行到安全点，如果运行到安全点时线程主动将自己挂起，并将自己当前的状态修改为运行到安全点这样就能保证所有的线程都在安全点，这也是目前默认的暂停方式

有了安全点设计，我们就可以完成GCRoots的枚举，正式切入到GC的过程中，但是安全点有一个小问题，那就是如果线程正在处于Blocked的状态怎么办

举一个例子，我们的两个线程争抢同一把锁，其中一个线程A获取锁后继续执行，而另一个线程B则被阻塞，A线程在归还锁前进入到安全点，将自己挂起，而B由于A的挂起将永远无法在这个GCRoots的枚举前获取到锁进而运行到安全点

为了解决这个问题，引入了安全区域，其实就是JVM标记许多代码区域，执行到这些代码区域的线程都被认为是安全的（在这个区域的线程不会发生引用的变化），比如线程的阻塞就是一个在安全区域的操作，因为阻塞的线程不会改变对象的引用，因此也可以进行GCRoots的枚举

常见的安全区域包括：

- 阻塞（`Object.wait()`、锁竞争失败）    
- 休眠（`Thread.sleep()`）
- I/O 等待

## 卡表与卡页

我们之前有提到过，为了解决跨代引用导致的对老年代扫描的问题，我们使用了记忆集，而在HotSpot中，记忆集通过卡表实现，卡表是一个数组，每个元素代表一个卡页，卡页代表一定范围内的内存区域，一旦这个卡页中存在跨代引用的对象，就将这个卡表的标识符修改为1，表示这个卡页变脏了，下次GC的时候就要扫描这个卡页上的对象

## 写屏障

由于JVM在解释后会将字节码转换为机械码流，因此必须思考如何能合理的介入卡表的更新操作，在HotSpot虚拟机中，JVM采用的是写屏障来维护卡表

JVM会将对象的赋值操作看作一个切面，围绕这个切面建立环绕通知，赋值前的称之为写前屏障，赋值后的成为写后屏障，而维护卡表的操作就在写屏障中

## 可达性分析

其实不光是GCRoots的枚举会暂停整个用户线程，理论上可达性分析的整个过程都会暂停用户线程，其中一个关键的一步就是从GCRoots向下进行递归寻找可达的对象，这一过程理论上是完全由对象的数量决定的，因此会导致很长的用户线程停顿时长，故而要对zhe'yi'guo'che