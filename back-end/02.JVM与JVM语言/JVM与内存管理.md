# JVM与内存管理

Java在运行时会将自己内部的内存划分为几个不同的区域，这些区域的总称叫做运行时数据区，根据Java虚拟机规范规定，JVM中运行时区域分为：

- 方法区
- 虚拟机栈
- 本地方法栈
- 堆
- 程序计数器

## 程序计数器

这块区域用来控制Java的运行流程（下一条应该执行哪个指令），在一个已知的时刻，一个内核只会执行一个线程中的指令。由此，在多线程编程中，该区域承担着保证线程切换后能恢复到之前的状态继续执行的功能，因此每个线程都会有一个独立的程序计数器，这一块是线程私有的内存。当当前线程执行的是Java方法时，此处存放的是一个虚拟字节码的地址，而执行的是Native方法时，存储的则是空（Undefined）

这块区域是在《Java虚拟机规范》中唯一一个没有规定OOM情况的区域

## Java虚拟机栈

类似C语言的栈，在进行方法调用时，JVM也会向栈中弹入一个栈帧，这个栈就是Java虚拟机栈。

由于每个线程都有自己的一套方法调用顺序，因此虚拟机栈也是线程独有的。虚拟机栈的每个栈帧中存放了当前方法的局部变量表、操作数栈、动态连接、方法出口等信息，直到该方法完全执行完毕，这个栈帧才会被弹出栈

局部变量表中存放了当前方法的所有局部变量，包含八种基本类型，对象引用和returnAddress
类型（指向了一条字节码指令的地址）

《Java虚拟机规范》中规定这个地方存在两种异常：

- 由于栈扩展时无法申请到足够的空间而导致的OOM（在HotSpot虚拟机中栈容量不可以扩展，所以不会因为扩展出现OOM，只要线程申请栈成功了就不会OOM，只有申请栈内存失败时才会出现OOM）
- 由于线程请求的栈深大于虚拟机栈最大允许的栈帧而导致的StackOverflowError（eg.过多的递归）

## 本地方法栈

与虚拟机栈类似，之哦是服务的对象是Java中的Native方法

## Java 堆

这块区域是所有线程共有的，根据《Java虚拟机规范》，几乎所有的对象实例的内存都是在这里分。由于这里是对象内存分配的位置，因此GC也在这里发生，故而又名为GC堆。由于对象的内存是在Java堆中开辟的，因此当没有足够的内存时就会出现OOM

## 方法区

方法区也是线程共有的内存区域，用于存储类型信息，常量，静态变量等数据，根据《Java虚拟机规范》，这块区域在逻辑上属于Java堆的一部分，但又专门使用了“Non-Heap”这一词汇来与Java堆进行区分。

在JDK8之前，存在一个叫做永久代的东西，这时HotSpot团队对方法区的实现方式，其他的JVM是没有永久代这个说法的，最初设计永久代是希望可以通过Java堆的GC一同将永久代的数据进行回收（是的，即时进了永久代也不能表示数据真正”永久“，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载），但是根据实际情况发现这一设计会导致很多Bug（主要是永久代的GC不理想照成的内存泄漏），因此在JDK8及以后的版本中彻底放弃了永久代的设计

由此我们不难发现，如果方法区无法满足内存分配需求，也会产生OOM

## 运行常量池

运行时常量池是方法区的一部分，承载了Class文件中的常量池表（内含编译期生成的各种字面量与符号引用）中的内容，运行常量池中处理符号引用外也会存放由符号引用转换而成的直接引用

当常量池无法再申请到内存时会出现OOM

## 对JVM中区域的总结

JVM作为Java乃至后续各种JVM语言的基石，其设计一定是相当合理的，JVM中的每一个区域都有自己的意义，共同实现JVM语言的运行。

- **虚拟机栈**：本质上实现的其实是语言中执行流程的问题，即单线程中下一句应该执行哪个代码，多线程中如何在切换线程时切换回原本的状态
- **虚拟机栈+本地方法栈**：解决方法调用方法的问题，以及隔离不同方法间各自的信息，进而实现了函数的各项功能
- **Java堆**：解决对象创建后内存分配以及生命周期的问题，实现了对于对象的托管
- **方法区+运行时常量池**：存储类的基本信息（类的元数据（类名、父类、接口、修饰符等），字面量（如字符串常量)， 符号引用（如类名、字段名、方法名等）等），是实现OOP的基石


## 直接内存

在Java1.4中新增的NIO中，我们可以直接通过Native函数库来直接分配堆外内存，然后通过DirectByteBuffer类来对这块内存进行操作，由于是直接操作物理内存，不用来回在Native堆和Java堆中拷贝，因此性能极高，但是内存肯定不可能是无限的，因此也会出现OOM的情况

## 对象实例的创建

一般Java程序会在检测到new关键字的时候创建对象，在创建对象前，JVM会现在常量池中尝试定位这个类，如果定位不到，就说明这个类还没有被加载，那么则会先进行加载

加载完成后，会先试图为实例开辟一段空间，根据JVM中内存是否规整（即是否完全分为两块区域：已使用和未使用，这两块区域应该相互隔离）存在两种方案：

- 当内存不规整时：JVM会维护一个空闲列表，用来记录哪些内存未被使用，当创建对象时，就从空闲列表中寻找一片空间给程序
- 当内存规整时：JVM会采用指针膨胀的形式，直接将用来分隔空闲区和非空闲区的指针进行移动，进而将空闲区的空间移动给非空闲去

为了保证空间分配这一过程的线程安全，JVM默认采用CAS+错误重试的机制来实现分配内存的原子性，除此之外还有一种模式就是给每个线程预先分配一段空间，线程创建对象只能在这个空间中创建，但该方式需要单独开启

再分配完空间后，会将空间中除了对象头的部分置为0，然后对对象头中数据进行设置（包含hashCode（这一部分是Lazy加载的，只有调用方法的hashCode方法才会得到），元数据，GC年龄等），上述过程完成后就视为在JVM层面创建了一个对象实例

不过在代码层面，还要执行构造方法，init方法，来完成实例中字段的传入

## 对象的布局

对象分为三部分：对象头，实例数据，对齐填充

其中对象头中包含两类数据，一类是存储对象自身运行时的数据，则个数据中包含哈希码，GC分代的年龄，锁状态的标志等内容，这一部分被精心设计为了32bit或64bit（根据你的系统是32位还是64位决定）

对象的另一部分为类型指针，用来表示这个对象实例对应的是哪个类。

然后是实例数据，就是程序员设计的字段的数据。

最后是对齐填充，由于HotSpot虚拟机中要求对象必须是8字节的倍数，因此会使用该空间将整个对象填充至8的倍数

## 对象的访问

我们都知道Java是通过引用直接访问到Java堆中开辟的对象，那么引用是如何访问到Java堆中的对象呢

