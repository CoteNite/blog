# 缓存设计

当服务器的流量过大时，我们往往会使用缓存的方式来减缓数据库压力，一般会使用Redis（分布式缓存），而Redis也有自己的问题（三大问题），因此会又会采取本地缓存（单机缓存）与其互补，让本地缓存预先再抗住一部分的流量

在一般的系统设计中，我们会预先对流量进行一系列的处理（OpenRestry，Sentinel，Guava RateLimter），之后才会到达我们的系统，这时我们一般就会认为这一次访问是正常的访问了，但在高并发的场景下（比如秒杀场景），我们仍然要想法设法的来避免大量流量导致的服务异常

## 整体设计

一般会从读写两个角度来看

### 读 

一般是层层递进，先去本地缓存去读，读不到进入分布式缓存，最后再去数据库读，若在某一层读到，则立即返回，同时异步的向前面的层去更新缓存

### 写

写的顺序一般是和读的顺序相反，用户持久化一个数据到数据库后，我们就立刻返回给用户一个结果，然后异步的去将持久化的数据更新到缓存中

## 技术选型

**本地缓存：**
- Guava Cache：Google Guava 包下内置的缓存方案，方便集成，但是性能一般
- **Caffeine**：Google 开源的本地缓存方案，集成难度相对Caffeine高一点（就一点点，可以忽略），但性能更好，且功能更加强大
- EhCache：功能丰富，支持多种储存层，与Hibernate的集成较好，但配置难度更高（使用xml配置），性能相对Caffeine也差一点

**分布式缓存:**
- **Redis**：目前市面上最常见的分布式缓存方案，将数据存储于内存中，有着可谓恐怖的读写性能，天生支持分布式，插件功能丰富（布隆过滤器/向量数据库）
- Memcached：一个比较老的缓存方案，也是将数据存储在内存中，但种种方面相对于Redis略显过时，一般都是老项目在用

**我个人会偏向使用Caffeine+Redis作为一个分布式项目的缓存方案**



