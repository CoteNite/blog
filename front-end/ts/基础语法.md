# 基础语法

JS的基本类型有布尔值，数值，字符串，null，undefined，Symbol（ES6）,BigInt（ES10）

### 布尔类型

```ts
let flag:boolean=false  //boolean类型
```

和Java一样，Boolean和boolean并非同一种类型

### 数值类型

```ts
let num:number=5
```

ts支持二进制和八进制

### 字符串类型

```ts
let str:string='232323'
```

### 空值

ts中使用void表示空值，这样也就解决了函数没有返回值的问题

```ts
function fun():void{
	alert('12')
}
```

## null与undefined

在ts中null和undefined用`null`和`undefined`类型来表示

```ts
let u: undefined = undefined;
let n: null = null;
```

这里的null与undefined是所有类型的子类

## any类型

ts中any类型是所有类的父类，也就是说你的所有类型的值都可以被赋值给一个any类型的变量

## 类型推断

```ts
let num=1  
console.log(num)
```

这样的写法是被允许的，因为ts会根据后面的值自动推断类型

## 联合类型

ts允许一个变量可以是多个类型，这种写法称之为联合类型(Union Type)

```ts
let a:number|string=1
a='12'
```

## 接口

ts中实现了接口，用来对一个类的形状进行定义

```ts
interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};
```

这里的age是一个可选属性，表示这个接口的实现类可以没有这个属性

### 任意属性

存在一种语法叫做任意属性，用来进一步开放接口，通过定义任意属性，我们可以让一个接口的实现类中存在多个定义之外的属性，

```ts
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}
```

以上代码的含义就是Person的实现类中除了name和age外还可以有其他自定义的参数，但是要求参数的key必须是string类型，value必须是any类型

值得注意的是，任意属性的要求对已经定义的属性仍然生效，因此你不能这么写

```ts
interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}
```

这样的话任意属性中的value会与已定义的age中的number类型冲突，进而导致报错

### 只读属性

你可以通过给接口的属性前面添加readonly关键字来将这个属性声明为只读属性，只读属性只能在实现类创建的时候进行一次定义


## 数组类型

ts中的数组存在多种定义方式

```ts
let ars1:number[]=[1,2,3]
let ars2:Array<number> =[1,2,3]
```

或者使用接口的方式

```ts
interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];
```

不过需要记住的是，js中的类数组，再ts中也是不能当作数组处理的，因此不能直接加入到数组中

## 函数

ts的函数与kotlin中的相似

```ts
function sum(x: number, y: number): number {
    return x + y;
}
```

### 函数表达式

ts的函数表达式与ES6中的定义一致，要求使用箭头表达式

```ts
let myFun:(x:number,y:number)=>number=function(x:number,y:number){
	return x+y
}
```

### 接口定义函数

我们也可以使用接口定义函数

```ts
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}
```

### 默认参数

同样的，ts也支持默认参数，你可以给参数添加一个默认值进而来避免传这个参数

```ts
function buildName(firstName: string = 'Tom', lastName: string) {
    return firstName + ' ' + lastName;
}
let tomcat = buildName('Tom', 'Cat');
let cat = buildName(undefined, 'Cat');
cat=buildName(lastname='cat')
```

### 可选参数

ts可以给函数定义可选参数，但是要求可选参数必须在函数的末尾

```ts
function fun(x:number,y?:number,z?:number){
    console.log(x,y,z)
}

fun(1)
fun(1,2)
fun(1,2,3)
```

### rest参数

ts可以使用rest参数传入一个数组，但要求rest参数必须作为函数的最后一个值

```js
function fun(a:number,...b:number[]){  
    b.push(a)  
    console.log(b)  
}  
  
fun(1,1,2,3,4,5,6,)
```

### 函数的重载

ts允许重载函数，但是写法有点怪，他是通过union type实现的

```ts
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
```

我们需要先写两个模板，然后再写一个公用的函数

## 类型断言

ts使用 `值 as 类型` 来让我们告诉编译器一个值是什么类型的

这一语法让我们z